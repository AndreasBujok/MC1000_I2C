
;************************************************
; 8039 Quarz = 3,6864 Mhz                       *
; f = 3,6864 Mhz / 3 = 1,2288 Mhz               *
; ALE = CLK / 5 = 245,76 kHz = 4,069 us         *
; TCLK int = ALE / 32 = 7,68 kHz = 130,2083 us  *
; 1 cyc = 4,069 us                              *
; 1 timer tick = 130 us                         *
; Syntax: Telemark TASM Version 3.2             *
;************************************************

#include "mc1000.inc";
#include "io.inc";
#include "i2c.inc";
#include "lcd_i2c.inc";



.org 0000h

_RESET		jmp INIT	; reset sprungadresse
		nop
_INT		jmp INTERRUPT	; interrupt sprungadresse
		nop
		nop
_TINT		jmp TIMERINT	; timer interrupt sprungadresse
		nop

.org 0010h
	; Platz fuer 16 Byte EPROM ID
	.byte	"0123456789abcdef"
	
	; ---------------- init --------------------
INIT	dis i		; (1 cyc) interrupt verhindern
	dis tcnti	; (1 cyc) timer interrupt verhindern
	ent0 clk	; (1 cyc) T0 prozessortakt ausgeben
	
	call I2CINIT	; init i2c - SDA and SCL high
	
	call WATCHDOG
	call WATCHDOG
	
x0	call I2CSTART	;
	call WATCHDOG
	
	mov r4,#$0a	; 10*10ms
	call wait	
	call WATCHDOG
	
	;*** Init Try 1
	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
	call I2COUT	;
	mov a,#$(%00111100) ; Function Set #1, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00111000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	;*** Init Try 2
	mov a,#$(%00111100) ; Function Set #2, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00111000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	;*** Init Try 3
	mov a,#$(%00111100) ; Function Set #3, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00111000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	; Init set 4bit mode
	mov a,#$(%00101100) ; Function Set, DL=0 4bit datalength, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00101000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	;***** Init sequence highnibble, low nibble
	
	; set 'Function Set' high nibble
	mov a,#$(%00101100) ; Functiom set DL=0 4bit datalength, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00101000) ; E=0, RS=0
	call I2COUT	;
	; set 'Function Set' low nibble
	mov a,#$(%10001100) ; N=1 2lines, F=0 5x7 dot, E=1, RS=0
	call I2COUT	;
	mov a,#$(%10001000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	; set 'Display Control' high nibble
	mov a,#$(%00001100) ; display control, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00001000) ; E=0, RS=0
	call I2COUT	;
	; set 'Display Control' low nibble
	mov a,#$(%11001100) ; D=1 display on, C=0 cursor off, B=0 blink cursor off, E=1, RS=0
	call I2COUT	;
	mov a,#$(%11001000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	; set 'Clear Control' high nibble
	mov a,#$(%00001100) ; clear display, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00001000) ; E=0, RS=0
	call I2COUT	;
	; set 'Display Control' low nibble
	mov a,#$(%00011100) ; clear display, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00011000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	; set 'Entry mode' high nibble
	mov a,#$(%00001100) ; entry mode, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00001000) ; E=0, RS=0
	call I2COUT	;
	; set 'Display Control' low nibble
	mov a,#$(%01101100) ; I/D=0 decrement, S=0 with display shift no, E=1, RS=0
	call I2COUT	;
	mov a,#$(%01101000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	; set 'Cursor At Home' high nibble
	mov a,#$(%00001100) ; Cursor At Home, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00001000) ; E=0, RS=0
	call I2COUT	;
	; set 'Display Control' low nibble
	mov a,#$(%00101100) ; Cursor At Home, E=1, RS=0
	call I2COUT	;
	mov a,#$(%00101000) ; E=0, RS=0
	call I2COUT	;
	
	mov r4,#$01	; 1*10ms
	call wait	
	call WATCHDOG
	
	
;	mov r1,#$00	; set index to 0
;	mov a,r1	; lade text index
;	movp3 a,@a	; hole zeichen aus P3, index akku
;	jz loop		; null byte endekennung?
;	movx @r0,a	; zeichen senden
;	inc r1		; text index++
;	jmp p_1		; naechstes Zeichen
	
	
	
	
	
	; write '@' high nibble
	mov a,#$(%01001101) ; high nibble '@', E=1, RS=1
	call I2COUT	;
	mov a,#$(%01001001) ; E=0, RS=1
	call I2COUT	;
	; set 'Display Control' low nibble
	mov a,#$(%00001101) ; low nibble '@', E=1, RS=1
	call I2COUT	;
	mov a,#$(%00001001) ; E=0, RS=1
	call I2COUT	;
	
	;jmp x1
	
;	mov r4,#$01	; 1*10ms
;	call wait	
;	call WATCHDOG
;	
	
	call I2CSTOP	;
	
x2	call WATCHDOG
	call WATCHDOG
	
	jmp x2
	
	


.org $0100

;*****************************************
; sekunde                                *
; Da aufwaertszahler, muss die diff zum  *
; ueberlauf als Wert gtenommen werden    *
; r4= n * 10ms
;*****************************************
wait		mov a,#0b3h	; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
		mov t,a		; (1 cyc) timer mit akkuwert laden
		call WATCHDOG	;
		strt t		; (1 cyc) timer starten
sek_2		jtf sek_3	; (2 cyc) timer abgelaufen
		jmp sek_2	; (2 cyc) warten bis timer abgelaufen
sek_3		stop tcnt	; (1 cyc) timer anhalten
		djnz r4,wait	; (2 cyc) repeat zaehler decrementieren
		ret		; (2 cyc) bye


;*****************************************
; I2C read data
; SDA & SCL should be low before
; r0= temp bitcounter
; r3= temp data
; A=  data
;*****************************************
I2CIN
	; SDA & SCL should here be low
	mov r0,#$08	; set bitcounter to 8-bit
	
	; loop over 8-bit data
I2CO01	
	orl p1,#$(1 << SCL) ; SCL high, clock rising
	in a,p1		; read P1x (SDA)
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	
	clr c		; C=0
	jb1 I2CO02	; SDA=1 (P1x)
	jmp I2CO03	; SDA=0 (P1x)
I2CO02	cpl c		; C=1
	
I2CO03	mov a,r3	; lopad temp data
	rlc a		; shift carry into A
	mov r3,a	; save temp data
	
	djnz r0,I2CO01	; decrement bitcounter,next loop r0>0
	
	; check bit-9 AKN/NAKN
	orl p1,#$(1 << SCL) ; SCL high, clock rising
	in a,p1		; read P1x
	nop		; carry to be define
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	
	ret


;*****************************************
; I2C write out address/date
; SDA & SCL should be low before
; data must be stable before and after clock
; A= address/data -> R3
; r0= temp bitcounter
; r3= temp address/data
;*****************************************
I2COUT	; SDA & SCL should here be low
	
	mov r0,#$08	; set bitcounter to 8-bit
	
	; loop over 8-bit adress+RW/data
I2CB01	mov r3,a	; set A to temp adress/data
	clr c		; prerpare carry
	mov a,r3	; load temp adress/data
	rlc a		; shift bit out into carry
	jc I2CB1	; bit set
	jmp I2CB2	; bit clear
I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	anl p1,#~(1 << SDA) ; SDA low, bit falling
	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
	
	; check bit-9 AKN/NAKN
	orl p1,#$(1 << SCL) ; SCL high, clock rising
	in a,p1		; read P1x
	nop		; carry to be define
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	
	ret


;;*****************************************
;; I2C write out address/date
;; SDA & SCL should be low before
;; data must be stable before and after clock
;; A= address/data -> R3
;; r0= temp bitcounter
;; r3= temp address/data
;; F0= R/W 1/0
;; F1= address/data 1/0
;;*****************************************
;I2COUT
;	mov r0,#$08	; set bitcounter to 8-bit
;	jf1 I2CB00	; F1=1 7-bit address mode + 1-bit RW
;	jmp I2CB01	; F1=0 8-bit data mode
;	
;	; adapt to address + R/W
;I2CB00	rl a		; convert A to address << 1 and b0=0 (write)
;	jf0 I2CB00A	; read mode
;	jmp I2CB01	; write mode
;I2CB00A	orl a,#$01	; b0=1 (read)
;	
;	; SDA & SCL should here be low
;	; loop over 8-bit adress+RW/data
;I2CB01	mov r3,a	; set A to temp adress/data
;	clr c		; prerpare carry
;	mov a,r3	; load temp adress/data
;	rlc a		; shift bit out into carry
;	jc I2CB1	; bit set
;	jmp I2CB2	; bit clear
;I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
;I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
;	anl p1,#~(1 << SCL) ; SCL low, clock falling
;	anl p1,#~(1 << SDA) ; SDA low, bit falling
;	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
;	
;	; check bit-9 AKN/NAKN
;	orl p1,#$(1 << SCL) ; SCL high, clock rising
;	in a,p1		; read P1x
;	nop		; carry to be define
;	anl p1,#~(1 << SCL) ; SCL low, clock falling
;	
;	ret


;*****************************************
; I2C init sequence
;*****************************************
I2CINIT	
	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
	ret


;*****************************************
; I2C start sequence
; SDA & SCL should be low before
;*****************************************
I2CSTART
	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
	anl p1,#~(1 << SDA)		; SDA low, SCL high
	anl p1,#~((1 << SDA)|(1 << SCL)) ; SDA & SCL low
	ret				;


;*****************************************
; I2C start sequence
; SDA & SCL should be low before
;*****************************************
I2CSTOP
	;in a,p1
	;outl p1,a
	orl p1,#$(1 << SCL)		; SCL high
	nop
	nop
	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
	nop
	ret				;


;*****************************************
;
;*****************************************
BCKLGHTON
	call I2CSTART	;
	; i2c address byte
	mov a,#I2CLCDWR	; i2c 7-bit LCD address
	clr F0		; set write mode
	clr F1		; set data  mode
	cpl F1		; set address mode
	call I2COUT
	
	


 ;************************************************
; Load SW1/SW2
; R3/R4= temporary result of SW1/SW2
; $20= result of SW1
; $21= result of SW2
;************************************************
rdSW12:
	mov	a,#$10		; init value-corunter
	mov	r2,a		; with %00010000
L0332:
	mov	a,r3		; move SW counter from r3
	mov	r4,a		; to SW counter r4
L0334:
	dec	r2		; value-counter r2--
	in	a,p1		; load current value of port1
	anl	a,#$F0		; cut low nibble
	orl	a,r2		; "add" value-counter r2 into
	outl	p1,a		; write back to port1
	mov	a,r3		; load A with r3
	clr	c		; clear carry
	jt1	L033F		; SW is "On"?
	cpl	c		; set carry (inverted val)
L033F:
	rlc	a		; fill value with carry from right
	mov	r3,a		; store result to counter r3
	mov	a,r2		; load counter r2
	jb3	L0332		; bit 3 set (SW2 active)?
	anl	a,#$0F		; cut high nibble
	jz	L034A		; value-counter clear
	jmp	L0334		; next loop, SW counter -> r4
L034A:
	mov	r0,#ZP_SW1	; set index ZP $20
	mov	a,r3		; store result from r3
	mov	@r0,a		; to RAM $20
	mov	r0,#ZP_SW2	; set index ZP $21
	mov	a,r4		; store result from r4
	mov	@r0,a		; to RAM $21
	ret			; bye


;*****************************************
; watchdog impuls |_|- high->low -> high *
; must be execute at least each ~630ms   *
;*****************************************
WATCHDOG:
	anl p2,#$(~b_WD)	; (2 cyc) P27 Watchdog low
	orl p2,#b_WD		; (2 cyc) P27 Watchdog high
	ret			; (2 cyc)



;***********************************************
; Timer interrupt routine alle 10,02 ms        *
;***********************************************
TIMERINT:
	retr
	
	
	mov a,#0b3h		; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
	mov t,a			; (1 cyc) timer mit akkuwert laden
	in a,p1			; (2 cyc) lese port #1 in kku
	xrl a,#b_WD		; (2 cyc) XOR akku mit bit 7
	outl p1,a		; (2 cyc) schreibe akku nach port #1
	retr			; (2 cyc) return mit PSW restore

;***********************************************
; interrupt routine                            *
;***********************************************
INTERRUPT:
	retr			;


.org $0300
	;      0123456789abcdef
	.text "Hallo Andreas  "
	.byte 00h


.end

