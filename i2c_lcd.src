
;************************************************
; 8039 Quarz = 3,6864 Mhz                       *
; f = 3,6864 Mhz / 3 = 1,2288 Mhz               *
; ALE = CLK / 5 = 245,76 kHz = 4,069 us         *
; TCLK int = ALE / 32 = 7,68 kHz = 130,2083 us  *
; 1 cyc = 4,069 us                              *
; 1 timer tick = 130 us                         *
; Syntax: Telemark TASM Version 3.2             *
;************************************************

#include "mc1000.inc";
#include "io.inc";
#include "i2c.inc";
#include "lcd_i2c.inc";



.org 0000h

_RESET		jmp INIT	; reset sprungadresse
		nop
_INT		jmp INTERRUPT	; interrupt sprungadresse
		nop
		nop
_TINT		jmp TIMERINT	; timer interrupt sprungadresse
		nop

.org 0010h
	; Platz fuer 16 Byte EPROM ID
	.byte	"0123456789abcdef"
	
	; ---------------- init --------------------
INIT	dis i		; (1 cyc) interrupt verhindern
	dis tcnti	; (1 cyc) timer interrupt verhindern
	ent0 clk	; (1 cyc) T0 prozessortakt ausgeben
	
	call I2CINIT	; init i2c - SDA and SCL high
	
	call WATCHDOG	; trigger P27
	
x0	call I2CSTART	; start I2C sequence
	
	;*** LCD Address
	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
	call I2COUT	; write to I2C
	
	call INITLCD	; init sequence LCD
	
	mov r4,#$0a	; 10*10ms
	call wait10	;
	call WATCHDOG	; trigger P27
	
	; print text to LCD
	mov r1,#$00	; set index to 0
p_1	mov a,r1	; lade text index
	movp3 a,@a	; hole zeichen aus P3, index akku
	jz x1		; null byte endekennung?
	call LCDDAT	; print chr on LCD
	inc r1		; text index++
	jmp p_1		; naechstes Zeichen
	
x1	call I2CSTOP	; stop I2C sequence
	
x2	call WATCHDOG
	
	jmp x2
	
	
	; write text to LCD
	mov a,#'@'
	call LCDDAT
	mov a,#' '
	call LCDDAT
	mov a,#'A'
	call LCDDAT
	mov a,#'n'
	call LCDDAT
	mov a,#'d'
	call LCDDAT
	mov a,#'r'
	call LCDDAT
	mov a,#'e'
	call LCDDAT
	mov a,#'a'
	call LCDDAT
	mov a,#'s'
	call LCDDAT
	
	
	
	
;	mov a,#$(%01001101) ; high nibble '@', E=1, RS=1
;	call I2COUT	;
;	mov a,#$(%01001001) ; E=0, RS=1
;	call I2COUT	;
;	; set 'Display Control' low nibble
;	mov a,#$(%00001101) ; low nibble '@', E=1, RS=1
;	call I2COUT	;
;	mov a,#$(%00001001) ; E=0, RS=1
;	call I2COUT	;
	
	;jmp x1
	
;	mov r4,#$01	; 1*10ms
;	call wait	
;	call WATCHDOG
;	
	
;x1	call I2CSTOP	;
	
;x2	call WATCHDOG
;	call WATCHDOG
;	
;	jmp x2
	
	


.org $0100


;*****************************************
; Init sequence LCD 4-bit value
; A= LCD 8bit-command
; r5= temp Port expander PCF8574
;*****************************************
INITLCD	;*** Init Try 1
	mov r5,#EXPWRCMD ; preset for P0-P3 expander, K=1, E=1, RW=0, RS=0
	mov a,#$(%00110000) ; Function Set #1, DL=1 8bit datalength
	call LCDCMDI	; write high nibble LCD cmd 
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	;*** Init Try 2
	mov r5,#EXPWRCMD ; preset for P0-P3 expander, K=1, E=1, RW=0, RS=0
	mov a,#$(%00110000) ; Function Set #2, DL=1 8bit datalength
	call LCDCMDI	; write high nibble LCD cmd 
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	;*** Init Try 3
	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
	mov a,#$(%00110000) ; Function Set #3, DL=1 8bit datalength
	call LCDCMDI	; write high nibble LCD cmd 
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	; Init set 4bit mode
	mov r5,#EXPWRCMD ; preset P0-P3 expander, K=1, E=1, RW=0, RS=0
	mov a,#$(%00101100) ; Function Set, DL=0 4bit datalength, E=1, RS=0
	call LCDCMDI	; write high nibble LCD cmd 
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	;***** valid Init sequence
	; set 'Function Set'
	mov a,#$(%00101000) ; Function set: DL=0 4bit, N=1 2lines, F=0 5x7 do
	call LCDCMD	; write 8-bit LCD command
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	; set 'Display Control'
	mov a,#$(%00001100) ; display control: D=1 display on, C=0 cursor off, B=0 blink cursor off
	call LCDCMD	; write 8-bit LCD command
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	; set 'Clear Control'
	mov a,#$(%00000001) ; clear display
	call LCDCMD	; write 8-bit LCD command
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	; set 'Entry mode'
	mov a,#$(%00000110) ; entry mode: I/D=1 increment, S=0 with display shift no
	call LCDCMD	; write 8-bit LCD command
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	; set 'Cursor At Home'
	mov a,#$(%00000010) ; 'Cursor At Home'
	call LCDCMD	; write 8-bit LCD command
	
	call wait10	; 1*10ms
	call WATCHDOG	; trigger P27
	
	ret		;bye




;*****************************************
; Write LCD 4-bit value
; A= LCD 8bit-command
; r5= temp Port expander PCF8574
; r6= temp LCD 8bit-value
;*****************************************
LCDCMD	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
	jmp LCD		;
LCDDAT	mov r5,#EXPWRDAT ; P0-P3 expander, K=1, E=1, RW=0, RS=1
	
	; set high nibble LCD command
LCD	mov r6,a	; store full 8-bit LCD-value
	anl a,#$F0	; cut low nibble from LCD-value
	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
	mov r5,a	; store expander full 8-bit port
	call I2COUT	; write to I2C
	mov a,r5	; load expander full 8-bit
	anl a,#$(%11111011) ; falling edge E=0
	call I2COUT	; write to I2C
	
	; set low nibble LCD command
	mov a,r6	; load full 8-bit LCD-value
	swap a		; xchange nibble, low -> high
	mov r6,a	; store modified full 8bit LCD-value
	mov a,r5	; load expander full 8-bit
	anl a,#$0f	; extract K, E, RW, RS
	mov r5,a	; store P0-P3 expander, (K, E, RW, RS)
	mov a,r6	; load full 8-bit LCD-value
LCDCMDI	anl a,#$F0	; cut low nibble LCD-value
	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
	mov r5,a	; store expander full 8-bit
	call I2COUT	; write to I2C
	mov a,r5	; load expander full 8-bit
	anl a,#$(%11111011) ; falling edge E=0
	call I2COUT	; write to I2C
	ret		; bye


;;*****************************************
;; Write LCD 4-bit command
;; A= LCD 8bit-command
;; r5= temp Port expander PCF8574
;; r6= temp LCD 8bit-command
;;*****************************************
;LCDCMD
;	; set high nibble LCD command
;	mov r6,a	; store 8-bit LCD-CMD
;	anl a,#$F0	; cut low nibble LCD-CMD
;	add a,#EXPWRCMD ; add P0-P3 expander, K=1, E=1, RW=0, RS=0
;	mov r5,a	; store expander 8-bit
;	call I2COUT	;
;	mov a,r5	; load expander 8-bit
;	anl a,#$(%11111011) ; E=0
;	call I2COUT	;
;	
;	; set low nibble LCD command
;	mov a,r6	; load 8-bit LCD-CMD
;	swap a		; xchange nibble, low -> high
;LCDCMDI	anl a,#$F0	; cut low nibble LCD-CMD
;	add a,#EXPWRCMD	; add P0-P3 expander, K=1, E=1, RW=0, RS=0
;	mov r5,a	; store expander 8-bit
;	call I2COUT	;
;	mov a,r5	; load expander 8-bit
;	anl a,#$(%11111011) ; E=0
;	call I2COUT	;
;	ret		;
;
;
;;*****************************************
;; Write LCD 4-bit data
;; A= LCD 8bit-data
;; r5= temp Port expander PCF8574
;; r6= temp LCD 8bit-command
;;*****************************************
;LCDDAT
;	; set high nibble LCD command
;	mov r6,a	; store 8-bit LCD-CMD
;	anl a,#$F0	; cut low nibble LCD-CMD
;	add a,#EXPWRDAT ; add P0-P3 expander, K=1, E=1, RW=0, RS=1
;	mov r5,a	; store expander 8-bit
;	call I2COUT	;
;	mov a,r5	; load expander 8-bit
;	anl a,#$(%11111011) ; E=0
;	call I2COUT	;
;	
;	; set low nibble LCD command
;	mov a,r6	; load 8-bit LCD-CMD
;	swap a		; xchange nibble, low -> high
;	anl a,#$F0	; cut low nibble LCD-CMD
;	add a,#EXPWRDAT	; add P0-P3 expander, K=1, E=1, RW=0, RS=1
;	mov r5,a	; store expander 8-bit
;	call I2COUT	;
;	mov a,r5	; load expander 8-bit
;	anl a,#$(%11111011) ; E=0
;	call I2COUT	;
;	ret		;


;*****************************************
; sekunde                                *
; Da aufwaertszahler, muss die diff zum  *
; ueberlauf als Wert gtenommen werden    *
; r4= n * 10ms
;*****************************************
wait10		mov r4,#$01	; 1*10ms
wait		mov a,#0b3h	; (1 cyc) 9,895 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
		mov t,a		; (1 cyc) timer mit akkuwert laden
t_start		call WATCHDOG	;
		strt t		; (1 cyc) timer starten
sek_2		jtf sek_3	; (2 cyc) timer abgelaufen
		jmp sek_2	; (2 cyc) warten bis timer abgelaufen
sek_3		stop tcnt	; (1 cyc) timer anhalten
		djnz r4,wait	; (2 cyc) repeat zaehler decrementieren
		ret		; (2 cyc) bye


;*****************************************
; I2C read data
; SDA & SCL should be low before
; r0= temp bitcounter
; r3= temp data
; A=  data
;*****************************************
I2CIN
	; SDA & SCL should here be low
	mov r0,#$08	; set bitcounter to 8-bit
	
	; loop over 8-bit data
I2CO01	
	orl p1,#$(1 << SCL) ; SCL high, clock rising
	in a,p1		; read P1x (SDA)
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	
	clr c		; C=0
	jb1 I2CO02	; SDA=1 (P1x)
	jmp I2CO03	; SDA=0 (P1x)
I2CO02	cpl c		; C=1
	
I2CO03	mov a,r3	; lopad temp data
	rlc a		; shift carry into A
	mov r3,a	; save temp data
	
	djnz r0,I2CO01	; decrement bitcounter,next loop r0>0
	
	; check bit-9 AKN/NAKN
	orl p1,#$(1 << SCL) ; SCL high, clock rising
	in a,p1		; read P1x
	nop		; carry to be define
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	
	ret


;*****************************************
; I2C write out address/date
; SDA & SCL should be low before
; data must be stable before and after clock
; A= address/data -> R3
; r0= temp bitcounter
; r3= temp address/data
;*****************************************
I2COUT	; SDA & SCL should here be low
	
	mov r0,#$08	; set bitcounter to 8-bit
	
	; loop over 8-bit adress+RW/data
I2CB01	mov r3,a	; set A to temp adress/data
	clr c		; prerpare carry
	mov a,r3	; load temp adress/data
	rlc a		; shift bit out into carry
	jc I2CB1	; bit set
	jmp I2CB2	; bit clear
I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	anl p1,#~(1 << SDA) ; SDA low, bit falling
	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
	
	; check bit-9 AKN/NAKN
	orl p1,#$(1 << SCL) ; SCL high, clock rising
	in a,p1		; read P1x
	nop		; carry to be define
	anl p1,#~(1 << SCL) ; SCL low, clock falling
	
	ret


;;*****************************************
;; I2C write out address/date
;; SDA & SCL should be low before
;; data must be stable before and after clock
;; A= address/data -> R3
;; r0= temp bitcounter
;; r3= temp address/data
;; F0= R/W 1/0
;; F1= address/data 1/0
;;*****************************************
;I2COUT
;	mov r0,#$08	; set bitcounter to 8-bit
;	jf1 I2CB00	; F1=1 7-bit address mode + 1-bit RW
;	jmp I2CB01	; F1=0 8-bit data mode
;	
;	; adapt to address + R/W
;I2CB00	rl a		; convert A to address << 1 and b0=0 (write)
;	jf0 I2CB00A	; read mode
;	jmp I2CB01	; write mode
;I2CB00A	orl a,#$01	; b0=1 (read)
;	
;	; SDA & SCL should here be low
;	; loop over 8-bit adress+RW/data
;I2CB01	mov r3,a	; set A to temp adress/data
;	clr c		; prerpare carry
;	mov a,r3	; load temp adress/data
;	rlc a		; shift bit out into carry
;	jc I2CB1	; bit set
;	jmp I2CB2	; bit clear
;I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
;I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
;	anl p1,#~(1 << SCL) ; SCL low, clock falling
;	anl p1,#~(1 << SDA) ; SDA low, bit falling
;	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
;	
;	; check bit-9 AKN/NAKN
;	orl p1,#$(1 << SCL) ; SCL high, clock rising
;	in a,p1		; read P1x
;	nop		; carry to be define
;	anl p1,#~(1 << SCL) ; SCL low, clock falling
;	
;	ret


;*****************************************
; I2C init sequence
;*****************************************
I2CINIT	
	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
	ret


;*****************************************
; I2C start sequence
; SDA & SCL should be low before
;*****************************************
I2CSTART
	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
	anl p1,#~(1 << SDA)		; SDA low, SCL high
	anl p1,#~((1 << SDA)|(1 << SCL)) ; SDA & SCL low
	ret				;


;*****************************************
; I2C start sequence
; SDA & SCL should be low before
;*****************************************
I2CSTOP
	;in a,p1
	;outl p1,a
	orl p1,#$(1 << SCL)		; SCL high
	nop
	nop
	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
	nop
	ret				;


 ;************************************************
; Load SW1/SW2
; R3/R4= temporary result of SW1/SW2
; $20= result of SW1
; $21= result of SW2
;************************************************
rdSW12:
	mov	a,#$10		; init value-corunter
	mov	r2,a		; with %00010000
L0332:
	mov	a,r3		; move SW counter from r3
	mov	r4,a		; to SW counter r4
L0334:
	dec	r2		; value-counter r2--
	in	a,p1		; load current value of port1
	anl	a,#$F0		; cut low nibble
	orl	a,r2		; "add" value-counter r2 into
	outl	p1,a		; write back to port1
	mov	a,r3		; load A with r3
	clr	c		; clear carry
	jt1	L033F		; SW is "On"?
	cpl	c		; set carry (inverted val)
L033F:
	rlc	a		; fill value with carry from right
	mov	r3,a		; store result to counter r3
	mov	a,r2		; load counter r2
	jb3	L0332		; bit 3 set (SW2 active)?
	anl	a,#$0F		; cut high nibble
	jz	L034A		; value-counter clear
	jmp	L0334		; next loop, SW counter -> r4
L034A:
	mov	r0,#ZP_SW1	; set index ZP $20
	mov	a,r3		; store result from r3
	mov	@r0,a		; to RAM $20
	mov	r0,#ZP_SW2	; set index ZP $21
	mov	a,r4		; store result from r4
	mov	@r0,a		; to RAM $21
	ret			; bye


;*****************************************
; watchdog impuls |_|- high->low -> high *
; must be execute at least each ~630ms   *
;*****************************************
WATCHDOG:
	anl p2,#$(~b_WD)	; (2 cyc) P27 Watchdog low
	orl p2,#b_WD		; (2 cyc) P27 Watchdog high
	ret			; (2 cyc)



;***********************************************
; Timer interrupt routine alle 10,02 ms        *
;***********************************************
TIMERINT:
	retr
	
	
	mov a,#0b3h		; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
	mov t,a			; (1 cyc) timer mit akkuwert laden
	in a,p1			; (2 cyc) lese port #1 in kku
	xrl a,#b_WD		; (2 cyc) XOR akku mit bit 7
	outl p1,a		; (2 cyc) schreibe akku nach port #1
	retr			; (2 cyc) return mit PSW restore

;***********************************************
; interrupt routine                            *
;***********************************************
INTERRUPT:
	retr			;


.org $0300
	;      0123456789abcdef
	.text "Hallo Andreas  "
	.byte 00h


.end

