0001   0000             
0002   0000             ;************************************************
0003   0000             ; 8039 Quarz = 3,6864 Mhz                       *
0004   0000             ; f = 3,6864 Mhz / 3 = 1,2288 Mhz               *
0005   0000             ; ALE = CLK / 5 = 245,76 kHz = 4,069 us         *
0006   0000             ; TCLK int = ALE / 32 = 7,68 kHz = 130,2083 us  *
0007   0000             ; 1 cyc = 4,069 us                              *
0008   0000             ; 1 timer tick = 130 us                         *
0009   0000             ; Syntax: Telemark TASM Version 3.2             *
0010   0000             ;************************************************
0011   0000             
0012   0000             #include "mc1000.inc";
0001+  0000             
0002+  0000             NUL	= $00	; null value
0003+  0000             CR	= $0d	; Carrage return
0004+  0000             LF	= $0A	; Line feed
0005+  0000             
0006+  0000             b_WD	= $80	; watchdog bit
0007+  0000             
0008+  0000             ZP_SW1	= $20	; result of switch #1 (call rdSW12)
0009+  0000             ZP_SW2	= $21	; result of switch #2 (call rdSW12)
0010+  0000             ZP_22	= $22	; rescue 8b (b82HEX))
0011+  0000             ZP_LNIB	= $23	; low nibble result of 8b
0012+  0000             ZP_HNIB	= $24	; high nibble result of 8b
0013+  0000             ZP_25	= $25	; working nibble result
0014+  0000             ZP_26	= $26	; last pressed raw key 7279
0015+  0000             
0016+  0000             
0017+  0000             
0013   0000             #include "io.inc";
0001+  0000             
0002+  0000             
0003+  0000             IO_CD		= $03 ; P13
0004+  0000             IO_RESET	= $04 ; P14, active high
0005+  0000             
0014   0000             #include "i2c.inc";
0001+  0000             
0002+  0000             SCL = 0	; P10
0003+  0000             SDA = 1	; P11
0004+  0000             
0005+  0000             
0015   0000             #include "lcd_i2c.inc";
0001+  0000             
0002+  0000             I2CLCDWR = %01001110
0003+  0000             I2CLCDRD = %01001111
0004+  0000             
0005+  0000             
0016   0000             
0017   0000             
0018   0000             
0019   0000             .org 0000h
0020   0000             
0021   0000 04 20       _RESET		jmp INIT	; reset sprungadresse
0022   0002 00          		nop
0023   0003 24 81       _INT		jmp INTERRUPT	; interrupt sprungadresse
0024   0005 00          		nop
0025   0006 00          		nop
0026   0007 24 78       _TINT		jmp TIMERINT	; timer interrupt sprungadresse
0027   0009 00          		nop
0028   000A             
0029   0010             .org 0010h
0030   0010             	; Platz fuer 16 Byte EPROM ID
0031   0010 30 31 32 33 	.byte	"0123456789abcdef"
0031   0014 34 35 36 37 
0031   0018 38 39 61 62 
0031   001C 63 64 65 66 
0032   0020             	
0033   0020             	; ---------------- init --------------------
0034   0020 15          INIT	dis i		; (1 cyc) interrupt verhindern
0035   0021 35          	dis tcnti	; (1 cyc) timer interrupt verhindern
0036   0022 75          	ent0 clk	; (1 cyc) T0 prozessortakt ausgeben
0037   0023             	
0038   0023 34 34       	call I2CINIT	; init i2c - SDA and SCL high
0039   0025             	
0040   0025 34 73       	call WATCHDOG
0041   0027 34 73       	call WATCHDOG
0042   0029             	
0043   0029 34 37       x0	call I2CSTART	;
0044   002B 34 73       	call WATCHDOG
0045   002D             	
0046   002D BC 0A       	mov r4,#$0a	; 10*10ms
0047   002F 14 E5       	call wait	
0048   0031 34 73       	call WATCHDOG
0049   0033             	
0050   0033             	;*** Init Try 1
0051   0033 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0052   0035 34 19       	call I2COUT	;
0053   0037 23 34       	mov a,#$(%00110100) ; Function Set #1, E=1, RS=0
0054   0039 34 19       	call I2COUT	;
0055   003B 23 30       	mov a,#$(%00110000) ; E=0, RS=0
0056   003D 34 19       	call I2COUT	;
0057   003F             	
0058   003F BC 01       	mov r4,#$01	; 1*10ms
0059   0041 14 E5       	call wait	
0060   0043 34 73       	call WATCHDOG
0061   0045             	
0062   0045             	;*** Init Try 2
0063   0045 23 34       	mov a,#$(%00110100) ; Function Set #2, E=1, RS=0
0064   0047 34 19       	call I2COUT	;
0065   0049 23 30       	mov a,#$(%00110000) ; E=0, RS=0
0066   004B 34 19       	call I2COUT	;
0067   004D             	
0068   004D BC 01       	mov r4,#$01	; 1*10ms
0069   004F 14 E5       	call wait	
0070   0051 34 73       	call WATCHDOG
0071   0053             	
0072   0053             	;*** Init Try 3
0073   0053 23 34       	mov a,#$(%00110100) ; Function Set #3, E=1, RS=0
0074   0055 34 19       	call I2COUT	;
0075   0057 23 30       	mov a,#$(%00110000) ; E=0, RS=0
0076   0059 34 19       	call I2COUT	;
0077   005B             	
0078   005B BC 01       	mov r4,#$01	; 1*10ms
0079   005D 14 E5       	call wait	
0080   005F 34 73       	call WATCHDOG
0081   0061             	
0082   0061             	; Init set 4bit mode
0083   0061 23 24       	mov a,#$(%00100100) ; Function Set, DL=0 4bit datalength, E=1, RS=0
0084   0063 34 19       	call I2COUT	;
0085   0065 23 20       	mov a,#$(%00100000) ; E=0, RS=0
0086   0067 34 19       	call I2COUT	;
0087   0069             	
0088   0069 BC 01       	mov r4,#$01	; 1*10ms
0089   006B 14 E5       	call wait	
0090   006D 34 73       	call WATCHDOG
0091   006F             	
0092   006F             	;***** Init sequence highnibble, low nibble
0093   006F             	
0094   006F             	; set 'Function Set' high nibble
0095   006F 23 24       	mov a,#$(%00100100) ; Functiom set DL=0 4bit datalength, E=1, RS=0
0096   0071 34 19       	call I2COUT	;
0097   0073 23 20       	mov a,#$(%00100000) ; E=0, RS=0
0098   0075 34 19       	call I2COUT	;
0099   0077             	; set 'Function Set' low nibble
0100   0077 23 84       	mov a,#$(%10000100) ; N=1 2lines, F=0 5x7 dot, E=1, RS=0
0101   0079 34 19       	call I2COUT	;
0102   007B 23 80       	mov a,#$(%10000000) ; E=0, RS=0
0103   007D 34 19       	call I2COUT	;
0104   007F             	
0105   007F BC 01       	mov r4,#$01	; 1*10ms
0106   0081 14 E5       	call wait	
0107   0083 34 73       	call WATCHDOG
0108   0085             	
0109   0085             	; set 'Display Control' high nibble
0110   0085 23 04       	mov a,#$(%00000100) ; display control, E=1, RS=0
0111   0087 34 19       	call I2COUT	;
0112   0089 23 00       	mov a,#$(%00000000) ; E=0, RS=0
0113   008B 34 19       	call I2COUT	;
0114   008D             	; set 'Display Control' low nibble
0115   008D 23 C4       	mov a,#$(%11000100) ; D=1 display on, C=0 cursor off, B=0 blink cursor off, E=1, RS=0
0116   008F 34 19       	call I2COUT	;
0117   0091 23 C0       	mov a,#$(%11000000) ; E=0, RS=0
0118   0093 34 19       	call I2COUT	;
0119   0095             	
0120   0095 BC 01       	mov r4,#$01	; 1*10ms
0121   0097 14 E5       	call wait	
0122   0099 34 73       	call WATCHDOG
0123   009B             	
0124   009B             	; set 'Clear Control' high nibble
0125   009B 23 04       	mov a,#$(%00000100) ; clear display, E=1, RS=0
0126   009D 34 19       	call I2COUT	;
0127   009F 23 00       	mov a,#$(%00000000) ; E=0, RS=0
0128   00A1 34 19       	call I2COUT	;
0129   00A3             	; set 'Display Control' low nibble
0130   00A3 23 14       	mov a,#$(%00010100) ; clear display, E=1, RS=0
0131   00A5 34 19       	call I2COUT	;
0132   00A7 23 10       	mov a,#$(%00010000) ; E=0, RS=0
0133   00A9 34 19       	call I2COUT	;
0134   00AB             	
0135   00AB BC 01       	mov r4,#$01	; 1*10ms
0136   00AD 14 E5       	call wait	
0137   00AF 34 73       	call WATCHDOG
0138   00B1             	
0139   00B1             	; set 'Entry mode' high nibble
0140   00B1 23 04       	mov a,#$(%00000100) ; entry mode, E=1, RS=0
0141   00B3 34 19       	call I2COUT	;
0142   00B5 23 00       	mov a,#$(%00000000) ; E=0, RS=0
0143   00B7 34 19       	call I2COUT	;
0144   00B9             	; set 'Display Control' low nibble
0145   00B9 23 64       	mov a,#$(%01100100) ; I/D=0 decrement, S=0 with display shift no, E=1, RS=0
0146   00BB 34 19       	call I2COUT	;
0147   00BD 23 60       	mov a,#$(%01100000) ; E=0, RS=0
0148   00BF 34 19       	call I2COUT	;
0149   00C1             	
0150   00C1 BC 01       	mov r4,#$01	; 1*10ms
0151   00C3 14 E5       	call wait	
0152   00C5 34 73       	call WATCHDOG
0153   00C7             	
0154   00C7             	; write '@' high nibble
0155   00C7 23 45       	mov a,#$(%01000101) ; high nibble '@', E=1, RS=1
0156   00C9 34 19       	call I2COUT	;
0157   00CB 23 41       	mov a,#$(%01000001) ; E=0, RS=1
0158   00CD 34 19       	call I2COUT	;
0159   00CF             	; set 'Display Control' low nibble
0160   00CF 23 05       	mov a,#$(%00000101) ; low nibble '@', E=1, RS=1
0161   00D1 34 19       	call I2COUT	;
0162   00D3 23 01       	mov a,#$(%00000001) ; E=0, RS=1
0163   00D5 34 19       	call I2COUT	;
0164   00D7             	
0165   00D7 BC 01       	mov r4,#$01	; 1*10ms
0166   00D9 14 E5       	call wait	
0167   00DB 34 73       	call WATCHDOG
0168   00DD             	
0169   00DD             	
0170   00DD 34 3E       	call I2CSTOP	;
0171   00DF             	
0172   00DF 34 73       	call WATCHDOG
0173   00E1 34 73       	call WATCHDOG
0174   00E3             	
0175   00E3 04 E3       	jmp $
0176   00E5             	
0177   00E5             	
0178   00E5             
0179   00E5             
0180   00E5             ;*****************************************
0181   00E5             ; sekunde                                *
0182   00E5             ; Da aufwaertszahler, muss die diff zum  *
0183   00E5             ; ueberlauf als Wert gtenommen werden    *
0184   00E5             ; r4= n * 10ms
0185   00E5             ;*****************************************
0186   00E5 23 B3       wait		mov a,#0b3h	; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0187   00E7 62          		mov t,a		; (1 cyc) timer mit akkuwert laden
0188   00E8 34 73       		call WATCHDOG	;
0189   00EA 55          		strt t		; (1 cyc) timer starten
0190   00EB 16 EF       sek_2		jtf sek_3	; (2 cyc) timer abgelaufen
0191   00ED 04 EB       		jmp sek_2	; (2 cyc) warten bis timer abgelaufen
0192   00EF 65          sek_3		stop tcnt	; (1 cyc) timer anhalten
0193   00F0 EC E5       		djnz r4,wait	; (2 cyc) repeat zaehler decrementieren
0194   00F2 83          		ret		; (2 cyc) bye
0195   00F3             
0196   00F3             
0197   0100             .org $0100
0198   0100             
0199   0100             ;*****************************************
0200   0100             ; I2C read data
0201   0100             ; SDA & SCL should be low before
0202   0100             ; r0= temp bitcounter
0203   0100             ; r3= temp data
0204   0100             ; A=  data
0205   0100             ;*****************************************
0206   0100             I2CIN
0207   0100             	; SDA & SCL should here be low
0208   0100 B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0209   0102             	
0210   0102             	; loop over 8-bit data
0211   0102             I2CO01	
0212   0102 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0213   0104 09          	in a,p1		; read P1x (SDA)
0214   0105 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0215   0107             	
0216   0107 97          	clr c		; C=0
0217   0108 32 0C       	jb1 I2CO02	; SDA=1 (P1x)
0218   010A 24 0D       	jmp I2CO03	; SDA=0 (P1x)
0219   010C A7          I2CO02	cpl c		; C=1
0220   010D             	
0221   010D FB          I2CO03	mov a,r3	; lopad temp data
0222   010E F7          	rlc a		; shift carry into A
0223   010F AB          	mov r3,a	; save temp data
0224   0110             	
0225   0110 E8 02       	djnz r0,I2CO01	; decrement bitcounter,next loop r0>0
0226   0112             	
0227   0112             	; check bit-9 AKN/NAKN
0228   0112 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0229   0114 09          	in a,p1		; read P1x
0230   0115 00          	nop		; carry to be define
0231   0116 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0232   0118             	
0233   0118 83          	ret
0234   0119             
0235   0119             
0236   0119             ;*****************************************
0237   0119             ; I2C write out address/date
0238   0119             ; SDA & SCL should be low before
0239   0119             ; data must be stable before and after clock
0240   0119             ; A= address/data -> R3
0241   0119             ; r0= temp bitcounter
0242   0119             ; r3= temp address/data
0243   0119             ;*****************************************
0244   0119             I2COUT	; SDA & SCL should here be low
0245   0119             	
0246   0119 B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0247   011B             	
0248   011B             	; loop over 8-bit adress+RW/data
0249   011B AB          I2CB01	mov r3,a	; set A to temp adress/data
0250   011C 97          	clr c		; prerpare carry
0251   011D FB          	mov a,r3	; load temp adress/data
0252   011E F7          	rlc a		; shift bit out into carry
0253   011F F6 23       	jc I2CB1	; bit set
0254   0121 24 25       	jmp I2CB2	; bit clear
0255   0123 89 02       I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0256   0125 89 01       I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0257   0127 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0258   0129 99 FD       	anl p1,#~(1 << SDA) ; SDA low, bit falling
0259   012B E8 1B       	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0260   012D             	
0261   012D             	; check bit-9 AKN/NAKN
0262   012D 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0263   012F 09          	in a,p1		; read P1x
0264   0130 00          	nop		; carry to be define
0265   0131 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0266   0133             	
0267   0133 83          	ret
0268   0134             
0269   0134             
0270   0134             ;;*****************************************
0271   0134             ;; I2C write out address/date
0272   0134             ;; SDA & SCL should be low before
0273   0134             ;; data must be stable before and after clock
0274   0134             ;; A= address/data -> R3
0275   0134             ;; r0= temp bitcounter
0276   0134             ;; r3= temp address/data
0277   0134             ;; F0= R/W 1/0
0278   0134             ;; F1= address/data 1/0
0279   0134             ;;*****************************************
0280   0134             ;I2COUT
0281   0134             ;	mov r0,#$08	; set bitcounter to 8-bit
0282   0134             ;	jf1 I2CB00	; F1=1 7-bit address mode + 1-bit RW
0283   0134             ;	jmp I2CB01	; F1=0 8-bit data mode
0284   0134             ;	
0285   0134             ;	; adapt to address + R/W
0286   0134             ;I2CB00	rl a		; convert A to address << 1 and b0=0 (write)
0287   0134             ;	jf0 I2CB00A	; read mode
0288   0134             ;	jmp I2CB01	; write mode
0289   0134             ;I2CB00A	orl a,#$01	; b0=1 (read)
0290   0134             ;	
0291   0134             ;	; SDA & SCL should here be low
0292   0134             ;	; loop over 8-bit adress+RW/data
0293   0134             ;I2CB01	mov r3,a	; set A to temp adress/data
0294   0134             ;	clr c		; prerpare carry
0295   0134             ;	mov a,r3	; load temp adress/data
0296   0134             ;	rlc a		; shift bit out into carry
0297   0134             ;	jc I2CB1	; bit set
0298   0134             ;	jmp I2CB2	; bit clear
0299   0134             ;I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0300   0134             ;I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0301   0134             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0302   0134             ;	anl p1,#~(1 << SDA) ; SDA low, bit falling
0303   0134             ;	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0304   0134             ;	
0305   0134             ;	; check bit-9 AKN/NAKN
0306   0134             ;	orl p1,#$(1 << SCL) ; SCL high, clock rising
0307   0134             ;	in a,p1		; read P1x
0308   0134             ;	nop		; carry to be define
0309   0134             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0310   0134             ;	
0311   0134             ;	ret
0312   0134             
0313   0134             
0314   0134             ;*****************************************
0315   0134             ; I2C init sequence
0316   0134             ;*****************************************
0317   0134             I2CINIT	
0318   0134 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0319   0136 83          	ret
0320   0137             
0321   0137             
0322   0137             ;*****************************************
0323   0137             ; I2C start sequence
0324   0137             ; SDA & SCL should be low before
0325   0137             ;*****************************************
0326   0137             I2CSTART
0327   0137 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0328   0139 99 FD       	anl p1,#~(1 << SDA)		; SDA low, SCL high
0329   013B 99 FC       	anl p1,#~((1 << SDA)|(1 << SCL)) ; SDA & SCL low
0330   013D 83          	ret				;
0331   013E             
0332   013E             
0333   013E             ;*****************************************
0334   013E             ; I2C start sequence
0335   013E             ; SDA & SCL should be low before
0336   013E             ;*****************************************
0337   013E             I2CSTOP
0338   013E             	;in a,p1
0339   013E             	;outl p1,a
0340   013E 89 01       	orl p1,#$(1 << SCL)		; SCL high
0341   0140 00          	nop
0342   0141 00          	nop
0343   0142 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0344   0144 00          	nop
0345   0145 83          	ret				;
0346   0146             
0347   0146             
0348   0146             ;*****************************************
0349   0146             ;
0350   0146             ;*****************************************
0351   0146             BCKLGHTON
0352   0146 34 37       	call I2CSTART	;
0353   0148             	; i2c address byte
0354   0148 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD address
0355   014A 85          	clr F0		; set write mode
0356   014B A5          	clr F1		; set data  mode
0357   014C B5          	cpl F1		; set address mode
0358   014D 34 19       	call I2COUT
0359   014F             	
0360   014F             	
0361   014F             
0362   014F             
0363   014F              ;************************************************
0364   014F             ; Load SW1/SW2
0365   014F             ; R3/R4= temporary result of SW1/SW2
0366   014F             ; $20= result of SW1
0367   014F             ; $21= result of SW2
0368   014F             ;************************************************
0369   014F             rdSW12:
0370   014F 23 10       	mov	a,#$10		; init value-corunter
0371   0151 AA          	mov	r2,a		; with %00010000
0372   0152             L0332:
0373   0152 FB          	mov	a,r3		; move SW counter from r3
0374   0153 AC          	mov	r4,a		; to SW counter r4
0375   0154             L0334:
0376   0154 CA          	dec	r2		; value-counter r2--
0377   0155 09          	in	a,p1		; load current value of port1
0378   0156 53 F0       	anl	a,#$F0		; cut low nibble
0379   0158 4A          	orl	a,r2		; "add" value-counter r2 into
0380   0159 39          	outl	p1,a		; write back to port1
0381   015A FB          	mov	a,r3		; load A with r3
0382   015B 97          	clr	c		; clear carry
0383   015C 56 5F       	jt1	L033F		; SW is "On"?
0384   015E A7          	cpl	c		; set carry (inverted val)
0385   015F             L033F:
0386   015F F7          	rlc	a		; fill value with carry from right
0387   0160 AB          	mov	r3,a		; store result to counter r3
0388   0161 FA          	mov	a,r2		; load counter r2
0389   0162 72 52       	jb3	L0332		; bit 3 set (SW2 active)?
0390   0164 53 0F       	anl	a,#$0F		; cut high nibble
0391   0166 C6 6A       	jz	L034A		; value-counter clear
0392   0168 24 54       	jmp	L0334		; next loop, SW counter -> r4
0393   016A             L034A:
0394   016A B8 20       	mov	r0,#ZP_SW1	; set index ZP $20
0395   016C FB          	mov	a,r3		; store result from r3
0396   016D A0          	mov	@r0,a		; to RAM $20
0397   016E B8 21       	mov	r0,#ZP_SW2	; set index ZP $21
0398   0170 FC          	mov	a,r4		; store result from r4
0399   0171 A0          	mov	@r0,a		; to RAM $21
0400   0172 83          	ret			; bye
0401   0173             
0402   0173             
0403   0173             ;*****************************************
0404   0173             ; watchdog impuls |_|- high->low -> high *
0405   0173             ; must be execute at least each ~630ms   *
0406   0173             ;*****************************************
0407   0173             WATCHDOG:
0408   0173 9A 7F       	anl p2,#$(~b_WD)	; (2 cyc) P27 Watchdog low
0409   0175 8A 80       	orl p2,#b_WD		; (2 cyc) P27 Watchdog high
0410   0177 83          	ret			; (2 cyc)
0411   0178             
0412   0178             
0413   0178             
0414   0178             ;***********************************************
0415   0178             ; Timer interrupt routine alle 10,02 ms        *
0416   0178             ;***********************************************
0417   0178             TIMERINT:
0418   0178 93          	retr
0419   0179             	
0420   0179             	
0421   0179 23 B3       	mov a,#0b3h		; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0422   017B 62          	mov t,a			; (1 cyc) timer mit akkuwert laden
0423   017C 09          	in a,p1			; (2 cyc) lese port #1 in kku
0424   017D D3 80       	xrl a,#b_WD		; (2 cyc) XOR akku mit bit 7
0425   017F 39          	outl p1,a		; (2 cyc) schreibe akku nach port #1
0426   0180 93          	retr			; (2 cyc) return mit PSW restore
0427   0181             
0428   0181             ;***********************************************
0429   0181             ; interrupt routine                            *
0430   0181             ;***********************************************
0431   0181             INTERRUPT:
0432   0181 93          	retr			;
0433   0182             
0434   0182             
0435   0182             
0436   0182             .end
0437   0182             



Type Key: N=NULL_SEG C=CODE_SEG B=BIT_SEG X=EXTD_SEG D=DATA_SEG
          L=Local
          E=Export

Value    Type   Label
-----    ----   ------------------------------
0146     N      BCKLGHTON                       
000D     N      CR                              
0003     N      IO_CD                           
0004     N      IO_RESET                        
004E     N      I2CLCDWR                        
004F     N      I2CLCDRD                        
0020     N      INIT                            
0100     N      I2CIN                           
0102     N      I2CO01                          
010C     N      I2CO02                          
010D     N      I2CO03                          
0119     N      I2COUT                          
011B     N      I2CB01                          
0123     N      I2CB1                           
0125     N      I2CB2                           
0134     N      I2CINIT                         
0137     N      I2CSTART                        
013E     N      I2CSTOP                         
0181     N      INTERRUPT                       
000A     N      LF                              
0152     N      L0332                           
0154     N      L0334                           
015F     N      L033F                           
016A     N      L034A                           
0000     N      NUL                             
0000     N      SCL                             
0001     N      SDA                             
0178     N      TIMERINT                        
0173     N      WATCHDOG                        
0020     N      ZP_SW1                          
0021     N      ZP_SW2                          
0022     N      ZP_22                           
0023     N      ZP_LNIB                         
0024     N      ZP_HNIB                         
0025     N      ZP_25                           
0026     N      ZP_26                           
0080     N      b_WD                            
0000     NL     noname._RESET                   
0003     NL     noname._INT                     
0007     NL     noname._TINT                    
014F     N      rdSW12                          
00EB     N      sek_2                           
00EF     N      sek_3                           
00E5     N      wait                            
0029     N      x0                              


ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------
0000  04 20 00 24 81 00 00 24 78 00 FF FF FF FF FF FF
0010  30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66
0020  15 35 75 34 34 34 73 34 73 34 37 34 73 BC 0A 14
0030  E5 34 73 23 4E 34 19 23 34 34 19 23 30 34 19 BC
0040  01 14 E5 34 73 23 34 34 19 23 30 34 19 BC 01 14
0050  E5 34 73 23 34 34 19 23 30 34 19 BC 01 14 E5 34
0060  73 23 24 34 19 23 20 34 19 BC 01 14 E5 34 73 23
0070  24 34 19 23 20 34 19 23 84 34 19 23 80 34 19 BC
0080  01 14 E5 34 73 23 04 34 19 23 00 34 19 23 C4 34
0090  19 23 C0 34 19 BC 01 14 E5 34 73 23 04 34 19 23
00A0  00 34 19 23 14 34 19 23 10 34 19 BC 01 14 E5 34
00B0  73 23 04 34 19 23 00 34 19 23 64 34 19 23 60 34
00C0  19 BC 01 14 E5 34 73 23 45 34 19 23 41 34 19 23
00D0  05 34 19 23 01 34 19 BC 01 14 E5 34 73 34 3E 34
00E0  73 34 73 04 E3 23 B3 62 34 73 55 16 EF 04 EB 65
00F0  EC E5 83 FF FF FF FF FF FF FF FF FF FF FF FF FF
0100  B8 08 89 01 09 99 FE 97 32 0C 24 0D A7 FB F7 AB
0110  E8 02 89 01 09 00 99 FE 83 B8 08 AB 97 FB F7 F6
0120  23 24 25 89 02 89 01 99 FE 99 FD E8 1B 89 01 09
0130  00 99 FE 83 89 03 83 89 03 99 FD 99 FC 83 89 01
0140  00 00 89 03 00 83 34 37 23 4E 85 A5 B5 34 19 23
0150  10 AA FB AC CA 09 53 F0 4A 39 FB 97 56 5F A7 F7
0160  AB FA 72 52 53 0F C6 6A 24 54 B8 20 FB A0 B8 21
0170  FC A0 83 9A 7F 8A 80 83 93 23 B3 62 09 D3 80 39
0180  93 93 FF FF FF FF FF FF FF FF FF FF FF FF FF FF


tasm: Number of errors = 0
