0001   0000             
0002   0000             ;************************************************
0003   0000             ; 8039 Quarz = 3,6864 Mhz                       *
0004   0000             ; f = 3,6864 Mhz / 3 = 1,2288 Mhz               *
0005   0000             ; ALE = CLK / 5 = 245,76 kHz = 4,069 us         *
0006   0000             ; TCLK int = ALE / 32 = 7,68 kHz = 130,2083 us  *
0007   0000             ; 1 cyc = 4,069 us                              *
0008   0000             ; 1 timer tick = 130 us                         *
0009   0000             ; Syntax: Telemark TASM Version 3.2             *
0010   0000             ;************************************************
0011   0000             
0012   0000             #include "mc1000.inc";
0001+  0000             
0002+  0000             NUL	= $00	; null value
0003+  0000             CR	= $0d	; Carrage return
0004+  0000             LF	= $0A	; Line feed
0005+  0000             
0006+  0000             b_WD	= $80	; watchdog bit
0007+  0000             
0008+  0000             ZP_SW1	= $20	; result of switch #1 (call rdSW12)
0009+  0000             ZP_SW2	= $21	; result of switch #2 (call rdSW12)
0010+  0000             ZP_22	= $22	; rescue 8b (b82HEX))
0011+  0000             ZP_LNIB	= $23	; low nibble result of 8b
0012+  0000             ZP_HNIB	= $24	; high nibble result of 8b
0013+  0000             ZP_25	= $25	; working nibble result
0014+  0000             ZP_26	= $26	; last pressed raw key 7279
0015+  0000             
0016+  0000             
0017+  0000             
0013   0000             #include "io.inc";
0001+  0000             
0002+  0000             
0003+  0000             IO_CD		= $03 ; P13
0004+  0000             IO_RESET	= $04 ; P14, active high
0005+  0000             
0014   0000             #include "i2c.inc";
0001+  0000             
0002+  0000             SCL = 0	; P10
0003+  0000             SDA = 1	; P11
0004+  0000             
0005+  0000             
0015   0000             #include "lcd_i2c.inc";
0001+  0000             
0002+  0000             I2CLCDWR = %01001110
0003+  0000             I2CLCDRD = %01001111
0004+  0000             
0005+  0000             
0016   0000             
0017   0000             
0018   0000             
0019   0000             .org 0000h
0020   0000             
0021   0000 04 20       _RESET		jmp INIT	; reset sprungadresse
0022   0002 00          		nop
0023   0003 24 8F       _INT		jmp INTERRUPT	; interrupt sprungadresse
0024   0005 00          		nop
0025   0006 00          		nop
0026   0007 24 86       _TINT		jmp TIMERINT	; timer interrupt sprungadresse
0027   0009 00          		nop
0028   000A             
0029   0010             .org 0010h
0030   0010             	; Platz fuer 16 Byte EPROM ID
0031   0010 30 31 32 33 	.byte	"0123456789abcdef"
0031   0014 34 35 36 37 
0031   0018 38 39 61 62 
0031   001C 63 64 65 66 
0032   0020             	
0033   0020             	; ---------------- init --------------------
0034   0020 15          INIT	dis i		; (1 cyc) interrupt verhindern
0035   0021 35          	dis tcnti	; (1 cyc) timer interrupt verhindern
0036   0022 75          	ent0 clk	; (1 cyc) T0 prozessortakt ausgeben
0037   0023             	
0038   0023 34 42       	call I2CINIT	; init i2c - SDA and SCL high
0039   0025             	
0040   0025 34 81       	call WATCHDOG
0041   0027 34 81       	call WATCHDOG
0042   0029             	
0043   0029 34 45       x0	call I2CSTART	;
0044   002B 34 81       	call WATCHDOG
0045   002D             	
0046   002D BC 0A       	mov r4,#$0a	; 10*10ms
0047   002F 34 00       	call wait	
0048   0031 34 81       	call WATCHDOG
0049   0033             	
0050   0033             	;*** Init Try 1
0051   0033 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0052   0035 34 27       	call I2COUT	;
0053   0037 23 3C       	mov a,#$(%00111100) ; Function Set #1, E=1, RS=0
0054   0039 34 27       	call I2COUT	;
0055   003B 23 38       	mov a,#$(%00111000) ; E=0, RS=0
0056   003D 34 27       	call I2COUT	;
0057   003F             	
0058   003F BC 01       	mov r4,#$01	; 1*10ms
0059   0041 34 00       	call wait	
0060   0043 34 81       	call WATCHDOG
0061   0045             	
0062   0045             	;*** Init Try 2
0063   0045 23 3C       	mov a,#$(%00111100) ; Function Set #2, E=1, RS=0
0064   0047 34 27       	call I2COUT	;
0065   0049 23 38       	mov a,#$(%00111000) ; E=0, RS=0
0066   004B 34 27       	call I2COUT	;
0067   004D             	
0068   004D BC 01       	mov r4,#$01	; 1*10ms
0069   004F 34 00       	call wait	
0070   0051 34 81       	call WATCHDOG
0071   0053             	
0072   0053             	;*** Init Try 3
0073   0053 23 3C       	mov a,#$(%00111100) ; Function Set #3, E=1, RS=0
0074   0055 34 27       	call I2COUT	;
0075   0057 23 38       	mov a,#$(%00111000) ; E=0, RS=0
0076   0059 34 27       	call I2COUT	;
0077   005B             	
0078   005B BC 01       	mov r4,#$01	; 1*10ms
0079   005D 34 00       	call wait	
0080   005F 34 81       	call WATCHDOG
0081   0061             	
0082   0061             	; Init set 4bit mode
0083   0061 23 2C       	mov a,#$(%00101100) ; Function Set, DL=0 4bit datalength, E=1, RS=0
0084   0063 34 27       	call I2COUT	;
0085   0065 23 28       	mov a,#$(%00101000) ; E=0, RS=0
0086   0067 34 27       	call I2COUT	;
0087   0069             	
0088   0069 BC 01       	mov r4,#$01	; 1*10ms
0089   006B 34 00       	call wait	
0090   006D 34 81       	call WATCHDOG
0091   006F             	
0092   006F             	;***** Init sequence highnibble, low nibble
0093   006F             	
0094   006F             	; set 'Function Set' high nibble
0095   006F 23 2C       	mov a,#$(%00101100) ; Functiom set DL=0 4bit datalength, E=1, RS=0
0096   0071 34 27       	call I2COUT	;
0097   0073 23 28       	mov a,#$(%00101000) ; E=0, RS=0
0098   0075 34 27       	call I2COUT	;
0099   0077             	; set 'Function Set' low nibble
0100   0077 23 8C       	mov a,#$(%10001100) ; N=1 2lines, F=0 5x7 dot, E=1, RS=0
0101   0079 34 27       	call I2COUT	;
0102   007B 23 88       	mov a,#$(%10001000) ; E=0, RS=0
0103   007D 34 27       	call I2COUT	;
0104   007F             	
0105   007F BC 01       	mov r4,#$01	; 1*10ms
0106   0081 34 00       	call wait	
0107   0083 34 81       	call WATCHDOG
0108   0085             	
0109   0085             	; set 'Display Control' high nibble
0110   0085 23 0C       	mov a,#$(%00001100) ; display control, E=1, RS=0
0111   0087 34 27       	call I2COUT	;
0112   0089 23 08       	mov a,#$(%00001000) ; E=0, RS=0
0113   008B 34 27       	call I2COUT	;
0114   008D             	; set 'Display Control' low nibble
0115   008D 23 CC       	mov a,#$(%11001100) ; D=1 display on, C=0 cursor off, B=0 blink cursor off, E=1, RS=0
0116   008F 34 27       	call I2COUT	;
0117   0091 23 C8       	mov a,#$(%11001000) ; E=0, RS=0
0118   0093 34 27       	call I2COUT	;
0119   0095             	
0120   0095 BC 01       	mov r4,#$01	; 1*10ms
0121   0097 34 00       	call wait	
0122   0099 34 81       	call WATCHDOG
0123   009B             	
0124   009B             	; set 'Clear Control' high nibble
0125   009B 23 0C       	mov a,#$(%00001100) ; clear display, E=1, RS=0
0126   009D 34 27       	call I2COUT	;
0127   009F 23 08       	mov a,#$(%00001000) ; E=0, RS=0
0128   00A1 34 27       	call I2COUT	;
0129   00A3             	; set 'Display Control' low nibble
0130   00A3 23 1C       	mov a,#$(%00011100) ; clear display, E=1, RS=0
0131   00A5 34 27       	call I2COUT	;
0132   00A7 23 18       	mov a,#$(%00011000) ; E=0, RS=0
0133   00A9 34 27       	call I2COUT	;
0134   00AB             	
0135   00AB BC 01       	mov r4,#$01	; 1*10ms
0136   00AD 34 00       	call wait	
0137   00AF 34 81       	call WATCHDOG
0138   00B1             	
0139   00B1             	; set 'Entry mode' high nibble
0140   00B1 23 0C       	mov a,#$(%00001100) ; entry mode, E=1, RS=0
0141   00B3 34 27       	call I2COUT	;
0142   00B5 23 08       	mov a,#$(%00001000) ; E=0, RS=0
0143   00B7 34 27       	call I2COUT	;
0144   00B9             	; set 'Display Control' low nibble
0145   00B9 23 6C       	mov a,#$(%01101100) ; I/D=0 decrement, S=0 with display shift no, E=1, RS=0
0146   00BB 34 27       	call I2COUT	;
0147   00BD 23 68       	mov a,#$(%01101000) ; E=0, RS=0
0148   00BF 34 27       	call I2COUT	;
0149   00C1             	
0150   00C1 BC 01       	mov r4,#$01	; 1*10ms
0151   00C3 34 00       	call wait	
0152   00C5 34 81       	call WATCHDOG
0153   00C7             	
0154   00C7             	; set 'Cursor At Home' high nibble
0155   00C7 23 0C       	mov a,#$(%00001100) ; Cursor At Home, E=1, RS=0
0156   00C9 34 27       	call I2COUT	;
0157   00CB 23 08       	mov a,#$(%00001000) ; E=0, RS=0
0158   00CD 34 27       	call I2COUT	;
0159   00CF             	; set 'Display Control' low nibble
0160   00CF 23 2C       	mov a,#$(%00101100) ; Cursor At Home, E=1, RS=0
0161   00D1 34 27       	call I2COUT	;
0162   00D3 23 28       	mov a,#$(%00101000) ; E=0, RS=0
0163   00D5 34 27       	call I2COUT	;
0164   00D7             	
0165   00D7 BC 01       	mov r4,#$01	; 1*10ms
0166   00D9 34 00       	call wait	
0167   00DB 34 81       	call WATCHDOG
0168   00DD             	
0169   00DD             	
0170   00DD             ;	mov r1,#$00	; set index to 0
0171   00DD             ;	mov a,r1	; lade text index
0172   00DD             ;	movp3 a,@a	; hole zeichen aus P3, index akku
0173   00DD             ;	jz loop		; null byte endekennung?
0174   00DD             ;	movx @r0,a	; zeichen senden
0175   00DD             ;	inc r1		; text index++
0176   00DD             ;	jmp p_1		; naechstes Zeichen
0177   00DD             	
0178   00DD             	
0179   00DD             	
0180   00DD             	
0181   00DD             	
0182   00DD             	; write '@' high nibble
0183   00DD 23 4D       	mov a,#$(%01001101) ; high nibble '@', E=1, RS=1
0184   00DF 34 27       	call I2COUT	;
0185   00E1 23 49       	mov a,#$(%01001001) ; E=0, RS=1
0186   00E3 34 27       	call I2COUT	;
0187   00E5             	; set 'Display Control' low nibble
0188   00E5 23 0D       	mov a,#$(%00001101) ; low nibble '@', E=1, RS=1
0189   00E7 34 27       	call I2COUT	;
0190   00E9 23 09       	mov a,#$(%00001001) ; E=0, RS=1
0191   00EB 34 27       	call I2COUT	;
0192   00ED             	
0193   00ED             	;jmp x1
0194   00ED             	
0195   00ED             ;	mov r4,#$01	; 1*10ms
0196   00ED             ;	call wait	
0197   00ED             ;	call WATCHDOG
0198   00ED             ;	
0199   00ED             	
0200   00ED 34 4C       	call I2CSTOP	;
0201   00EF             	
0202   00EF 34 81       x2	call WATCHDOG
0203   00F1 34 81       	call WATCHDOG
0204   00F3             	
0205   00F3 04 EF       	jmp x2
0206   00F5             	
0207   00F5             	
0208   00F5             
0209   00F5             
0210   0100             .org $0100
0211   0100             
0212   0100             ;*****************************************
0213   0100             ; sekunde                                *
0214   0100             ; Da aufwaertszahler, muss die diff zum  *
0215   0100             ; ueberlauf als Wert gtenommen werden    *
0216   0100             ; r4= n * 10ms
0217   0100             ;*****************************************
0218   0100 23 B3       wait		mov a,#0b3h	; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0219   0102 62          		mov t,a		; (1 cyc) timer mit akkuwert laden
0220   0103 34 81       		call WATCHDOG	;
0221   0105 55          		strt t		; (1 cyc) timer starten
0222   0106 16 0A       sek_2		jtf sek_3	; (2 cyc) timer abgelaufen
0223   0108 24 06       		jmp sek_2	; (2 cyc) warten bis timer abgelaufen
0224   010A 65          sek_3		stop tcnt	; (1 cyc) timer anhalten
0225   010B EC 00       		djnz r4,wait	; (2 cyc) repeat zaehler decrementieren
0226   010D 83          		ret		; (2 cyc) bye
0227   010E             
0228   010E             
0229   010E             ;*****************************************
0230   010E             ; I2C read data
0231   010E             ; SDA & SCL should be low before
0232   010E             ; r0= temp bitcounter
0233   010E             ; r3= temp data
0234   010E             ; A=  data
0235   010E             ;*****************************************
0236   010E             I2CIN
0237   010E             	; SDA & SCL should here be low
0238   010E B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0239   0110             	
0240   0110             	; loop over 8-bit data
0241   0110             I2CO01	
0242   0110 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0243   0112 09          	in a,p1		; read P1x (SDA)
0244   0113 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0245   0115             	
0246   0115 97          	clr c		; C=0
0247   0116 32 1A       	jb1 I2CO02	; SDA=1 (P1x)
0248   0118 24 1B       	jmp I2CO03	; SDA=0 (P1x)
0249   011A A7          I2CO02	cpl c		; C=1
0250   011B             	
0251   011B FB          I2CO03	mov a,r3	; lopad temp data
0252   011C F7          	rlc a		; shift carry into A
0253   011D AB          	mov r3,a	; save temp data
0254   011E             	
0255   011E E8 10       	djnz r0,I2CO01	; decrement bitcounter,next loop r0>0
0256   0120             	
0257   0120             	; check bit-9 AKN/NAKN
0258   0120 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0259   0122 09          	in a,p1		; read P1x
0260   0123 00          	nop		; carry to be define
0261   0124 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0262   0126             	
0263   0126 83          	ret
0264   0127             
0265   0127             
0266   0127             ;*****************************************
0267   0127             ; I2C write out address/date
0268   0127             ; SDA & SCL should be low before
0269   0127             ; data must be stable before and after clock
0270   0127             ; A= address/data -> R3
0271   0127             ; r0= temp bitcounter
0272   0127             ; r3= temp address/data
0273   0127             ;*****************************************
0274   0127             I2COUT	; SDA & SCL should here be low
0275   0127             	
0276   0127 B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0277   0129             	
0278   0129             	; loop over 8-bit adress+RW/data
0279   0129 AB          I2CB01	mov r3,a	; set A to temp adress/data
0280   012A 97          	clr c		; prerpare carry
0281   012B FB          	mov a,r3	; load temp adress/data
0282   012C F7          	rlc a		; shift bit out into carry
0283   012D F6 31       	jc I2CB1	; bit set
0284   012F 24 33       	jmp I2CB2	; bit clear
0285   0131 89 02       I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0286   0133 89 01       I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0287   0135 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0288   0137 99 FD       	anl p1,#~(1 << SDA) ; SDA low, bit falling
0289   0139 E8 29       	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0290   013B             	
0291   013B             	; check bit-9 AKN/NAKN
0292   013B 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0293   013D 09          	in a,p1		; read P1x
0294   013E 00          	nop		; carry to be define
0295   013F 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0296   0141             	
0297   0141 83          	ret
0298   0142             
0299   0142             
0300   0142             ;;*****************************************
0301   0142             ;; I2C write out address/date
0302   0142             ;; SDA & SCL should be low before
0303   0142             ;; data must be stable before and after clock
0304   0142             ;; A= address/data -> R3
0305   0142             ;; r0= temp bitcounter
0306   0142             ;; r3= temp address/data
0307   0142             ;; F0= R/W 1/0
0308   0142             ;; F1= address/data 1/0
0309   0142             ;;*****************************************
0310   0142             ;I2COUT
0311   0142             ;	mov r0,#$08	; set bitcounter to 8-bit
0312   0142             ;	jf1 I2CB00	; F1=1 7-bit address mode + 1-bit RW
0313   0142             ;	jmp I2CB01	; F1=0 8-bit data mode
0314   0142             ;	
0315   0142             ;	; adapt to address + R/W
0316   0142             ;I2CB00	rl a		; convert A to address << 1 and b0=0 (write)
0317   0142             ;	jf0 I2CB00A	; read mode
0318   0142             ;	jmp I2CB01	; write mode
0319   0142             ;I2CB00A	orl a,#$01	; b0=1 (read)
0320   0142             ;	
0321   0142             ;	; SDA & SCL should here be low
0322   0142             ;	; loop over 8-bit adress+RW/data
0323   0142             ;I2CB01	mov r3,a	; set A to temp adress/data
0324   0142             ;	clr c		; prerpare carry
0325   0142             ;	mov a,r3	; load temp adress/data
0326   0142             ;	rlc a		; shift bit out into carry
0327   0142             ;	jc I2CB1	; bit set
0328   0142             ;	jmp I2CB2	; bit clear
0329   0142             ;I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0330   0142             ;I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0331   0142             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0332   0142             ;	anl p1,#~(1 << SDA) ; SDA low, bit falling
0333   0142             ;	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0334   0142             ;	
0335   0142             ;	; check bit-9 AKN/NAKN
0336   0142             ;	orl p1,#$(1 << SCL) ; SCL high, clock rising
0337   0142             ;	in a,p1		; read P1x
0338   0142             ;	nop		; carry to be define
0339   0142             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0340   0142             ;	
0341   0142             ;	ret
0342   0142             
0343   0142             
0344   0142             ;*****************************************
0345   0142             ; I2C init sequence
0346   0142             ;*****************************************
0347   0142             I2CINIT	
0348   0142 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0349   0144 83          	ret
0350   0145             
0351   0145             
0352   0145             ;*****************************************
0353   0145             ; I2C start sequence
0354   0145             ; SDA & SCL should be low before
0355   0145             ;*****************************************
0356   0145             I2CSTART
0357   0145 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0358   0147 99 FD       	anl p1,#~(1 << SDA)		; SDA low, SCL high
0359   0149 99 FC       	anl p1,#~((1 << SDA)|(1 << SCL)) ; SDA & SCL low
0360   014B 83          	ret				;
0361   014C             
0362   014C             
0363   014C             ;*****************************************
0364   014C             ; I2C start sequence
0365   014C             ; SDA & SCL should be low before
0366   014C             ;*****************************************
0367   014C             I2CSTOP
0368   014C             	;in a,p1
0369   014C             	;outl p1,a
0370   014C 89 01       	orl p1,#$(1 << SCL)		; SCL high
0371   014E 00          	nop
0372   014F 00          	nop
0373   0150 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0374   0152 00          	nop
0375   0153 83          	ret				;
0376   0154             
0377   0154             
0378   0154             ;*****************************************
0379   0154             ;
0380   0154             ;*****************************************
0381   0154             BCKLGHTON
0382   0154 34 45       	call I2CSTART	;
0383   0156             	; i2c address byte
0384   0156 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD address
0385   0158 85          	clr F0		; set write mode
0386   0159 A5          	clr F1		; set data  mode
0387   015A B5          	cpl F1		; set address mode
0388   015B 34 27       	call I2COUT
0389   015D             	
0390   015D             	
0391   015D             
0392   015D             
0393   015D              ;************************************************
0394   015D             ; Load SW1/SW2
0395   015D             ; R3/R4= temporary result of SW1/SW2
0396   015D             ; $20= result of SW1
0397   015D             ; $21= result of SW2
0398   015D             ;************************************************
0399   015D             rdSW12:
0400   015D 23 10       	mov	a,#$10		; init value-corunter
0401   015F AA          	mov	r2,a		; with %00010000
0402   0160             L0332:
0403   0160 FB          	mov	a,r3		; move SW counter from r3
0404   0161 AC          	mov	r4,a		; to SW counter r4
0405   0162             L0334:
0406   0162 CA          	dec	r2		; value-counter r2--
0407   0163 09          	in	a,p1		; load current value of port1
0408   0164 53 F0       	anl	a,#$F0		; cut low nibble
0409   0166 4A          	orl	a,r2		; "add" value-counter r2 into
0410   0167 39          	outl	p1,a		; write back to port1
0411   0168 FB          	mov	a,r3		; load A with r3
0412   0169 97          	clr	c		; clear carry
0413   016A 56 6D       	jt1	L033F		; SW is "On"?
0414   016C A7          	cpl	c		; set carry (inverted val)
0415   016D             L033F:
0416   016D F7          	rlc	a		; fill value with carry from right
0417   016E AB          	mov	r3,a		; store result to counter r3
0418   016F FA          	mov	a,r2		; load counter r2
0419   0170 72 60       	jb3	L0332		; bit 3 set (SW2 active)?
0420   0172 53 0F       	anl	a,#$0F		; cut high nibble
0421   0174 C6 78       	jz	L034A		; value-counter clear
0422   0176 24 62       	jmp	L0334		; next loop, SW counter -> r4
0423   0178             L034A:
0424   0178 B8 20       	mov	r0,#ZP_SW1	; set index ZP $20
0425   017A FB          	mov	a,r3		; store result from r3
0426   017B A0          	mov	@r0,a		; to RAM $20
0427   017C B8 21       	mov	r0,#ZP_SW2	; set index ZP $21
0428   017E FC          	mov	a,r4		; store result from r4
0429   017F A0          	mov	@r0,a		; to RAM $21
0430   0180 83          	ret			; bye
0431   0181             
0432   0181             
0433   0181             ;*****************************************
0434   0181             ; watchdog impuls |_|- high->low -> high *
0435   0181             ; must be execute at least each ~630ms   *
0436   0181             ;*****************************************
0437   0181             WATCHDOG:
0438   0181 9A 7F       	anl p2,#$(~b_WD)	; (2 cyc) P27 Watchdog low
0439   0183 8A 80       	orl p2,#b_WD		; (2 cyc) P27 Watchdog high
0440   0185 83          	ret			; (2 cyc)
0441   0186             
0442   0186             
0443   0186             
0444   0186             ;***********************************************
0445   0186             ; Timer interrupt routine alle 10,02 ms        *
0446   0186             ;***********************************************
0447   0186             TIMERINT:
0448   0186 93          	retr
0449   0187             	
0450   0187             	
0451   0187 23 B3       	mov a,#0b3h		; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0452   0189 62          	mov t,a			; (1 cyc) timer mit akkuwert laden
0453   018A 09          	in a,p1			; (2 cyc) lese port #1 in kku
0454   018B D3 80       	xrl a,#b_WD		; (2 cyc) XOR akku mit bit 7
0455   018D 39          	outl p1,a		; (2 cyc) schreibe akku nach port #1
0456   018E 93          	retr			; (2 cyc) return mit PSW restore
0457   018F             
0458   018F             ;***********************************************
0459   018F             ; interrupt routine                            *
0460   018F             ;***********************************************
0461   018F             INTERRUPT:
0462   018F 93          	retr			;
0463   0190             
0464   0190             
0465   0300             .org $0300
0466   0300             	;      0123456789abcdef
0467   0300 48 61 6C 6C 	.text "Hallo Andreas  "
0467   0304 6F 20 41 6E 
0467   0308 64 72 65 61 
0467   030C 73 20 20 
0468   030F 00          	.byte 00h
0469   0310             
0470   0310             
0471   0310             .end
0472   0310             



Type Key: N=NULL_SEG C=CODE_SEG B=BIT_SEG X=EXTD_SEG D=DATA_SEG
          L=Local
          E=Export

Value    Type   Label
-----    ----   ------------------------------
0154     N      BCKLGHTON                       
000D     N      CR                              
0003     N      IO_CD                           
0004     N      IO_RESET                        
004E     N      I2CLCDWR                        
004F     N      I2CLCDRD                        
0020     N      INIT                            
010E     N      I2CIN                           
0110     N      I2CO01                          
011A     N      I2CO02                          
011B     N      I2CO03                          
0127     N      I2COUT                          
0129     N      I2CB01                          
0131     N      I2CB1                           
0133     N      I2CB2                           
0142     N      I2CINIT                         
0145     N      I2CSTART                        
014C     N      I2CSTOP                         
018F     N      INTERRUPT                       
000A     N      LF                              
0160     N      L0332                           
0162     N      L0334                           
016D     N      L033F                           
0178     N      L034A                           
0000     N      NUL                             
0000     N      SCL                             
0001     N      SDA                             
0186     N      TIMERINT                        
0181     N      WATCHDOG                        
0020     N      ZP_SW1                          
0021     N      ZP_SW2                          
0022     N      ZP_22                           
0023     N      ZP_LNIB                         
0024     N      ZP_HNIB                         
0025     N      ZP_25                           
0026     N      ZP_26                           
0080     N      b_WD                            
0000     NL     noname._RESET                   
0003     NL     noname._INT                     
0007     NL     noname._TINT                    
015D     N      rdSW12                          
0106     N      sek_2                           
010A     N      sek_3                           
0100     N      wait                            
0029     N      x0                              
00EF     N      x2                              


ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------
0000  04 20 00 24 8F 00 00 24 86 00 FF FF FF FF FF FF
0010  30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66
0020  15 35 75 34 42 34 81 34 81 34 45 34 81 BC 0A 34
0030  00 34 81 23 4E 34 27 23 3C 34 27 23 38 34 27 BC
0040  01 34 00 34 81 23 3C 34 27 23 38 34 27 BC 01 34
0050  00 34 81 23 3C 34 27 23 38 34 27 BC 01 34 00 34
0060  81 23 2C 34 27 23 28 34 27 BC 01 34 00 34 81 23
0070  2C 34 27 23 28 34 27 23 8C 34 27 23 88 34 27 BC
0080  01 34 00 34 81 23 0C 34 27 23 08 34 27 23 CC 34
0090  27 23 C8 34 27 BC 01 34 00 34 81 23 0C 34 27 23
00A0  08 34 27 23 1C 34 27 23 18 34 27 BC 01 34 00 34
00B0  81 23 0C 34 27 23 08 34 27 23 6C 34 27 23 68 34
00C0  27 BC 01 34 00 34 81 23 0C 34 27 23 08 34 27 23
00D0  2C 34 27 23 28 34 27 BC 01 34 00 34 81 23 4D 34
00E0  27 23 49 34 27 23 0D 34 27 23 09 34 27 34 4C 34
00F0  81 34 81 04 EF FF FF FF FF FF FF FF FF FF FF FF
0100  23 B3 62 34 81 55 16 0A 24 06 65 EC 00 83 B8 08
0110  89 01 09 99 FE 97 32 1A 24 1B A7 FB F7 AB E8 10
0120  89 01 09 00 99 FE 83 B8 08 AB 97 FB F7 F6 31 24
0130  33 89 02 89 01 99 FE 99 FD E8 29 89 01 09 00 99
0140  FE 83 89 03 83 89 03 99 FD 99 FC 83 89 01 00 00
0150  89 03 00 83 34 45 23 4E 85 A5 B5 34 27 23 10 AA
0160  FB AC CA 09 53 F0 4A 39 FB 97 56 6D A7 F7 AB FA
0170  72 60 53 0F C6 78 24 62 B8 20 FB A0 B8 21 FC A0
0180  83 9A 7F 8A 80 83 93 23 B3 62 09 D3 80 39 93 93
0190  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01A0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01B0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01C0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0200  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0210  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0220  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0230  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0240  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0250  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0260  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0270  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0280  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0290  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02A0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02B0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02C0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0300  48 61 6C 6C 6F 20 41 6E 64 72 65 61 73 20 20 00


tasm: Number of errors = 0
