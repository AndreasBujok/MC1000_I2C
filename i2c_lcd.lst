0001   0000             
0002   0000             ;************************************************
0003   0000             ; 8039 Quarz = 3,6864 Mhz                       *
0004   0000             ; f = 3,6864 Mhz / 3 = 1,2288 Mhz               *
0005   0000             ; ALE = CLK / 5 = 245,76 kHz = 4,069 us         *
0006   0000             ; TCLK int = ALE / 32 = 7,68 kHz = 130,2083 us  *
0007   0000             ; 1 cyc = 4,069 us                              *
0008   0000             ; 1 timer tick = 130 us                         *
0009   0000             ; Syntax: Telemark TASM Version 3.2             *
0010   0000             ;************************************************
0011   0000             
0012   0000             #include "mc1000.inc";
0001+  0000             
0002+  0000             NUL	= $00	; null value
0003+  0000             CR	= $0d	; Carrage return
0004+  0000             LF	= $0A	; Line feed
0005+  0000             
0006+  0000             b_WD	= $80	; watchdog bit
0007+  0000             
0008+  0000             ZP_SW1	= $20	; result of switch #1 (call rdSW12)
0009+  0000             ZP_SW2	= $21	; result of switch #2 (call rdSW12)
0010+  0000             ZP_22	= $22	; rescue 8b (b82HEX))
0011+  0000             ZP_LNIB	= $23	; low nibble result of 8b
0012+  0000             ZP_HNIB	= $24	; high nibble result of 8b
0013+  0000             ZP_25	= $25	; working nibble result
0014+  0000             ZP_26	= $26	; last pressed raw key 7279
0015+  0000             
0016+  0000             
0017+  0000             
0013   0000             #include "io.inc";
0001+  0000             
0002+  0000             
0003+  0000             IO_CD		= $03 ; P13
0004+  0000             IO_RESET	= $04 ; P14, active high
0005+  0000             
0014   0000             #include "i2c.inc";
0001+  0000             
0002+  0000             SCL = 0	; P10
0003+  0000             SDA = 1	; P11
0004+  0000             
0005+  0000             
0015   0000             #include "lcd_i2c.inc";
0001+  0000             
0002+  0000             I2CLCDWR = %01001110
0003+  0000             I2CLCDRD = %01001111
0004+  0000             
0005+  0000             EXPWRCMD = %00001100 ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0006+  0000             EXPWRDAT = %00001101 ; P0-P3 expander, K=1, E=1, RW=0, RS=1
0007+  0000             RS	= 0 ; P0 PCF8574, Register Select
0008+  0000             RW	= 1 ; P1 PCF8574, Read/Write
0009+  0000             E	= 2 ; P2 PCF8574, Enable, commit by falling edge
0010+  0000             K	= 3 ; P3 PCF8574, LCD Backlight, K=1 On, K=0 Off
0011+  0000             
0012+  0000             
0013+  0000             
0016   0000             
0017   0000             
0018   0000             
0019   0000             .org 0000h
0020   0000             
0021   0000 04 20       _RESET		jmp INIT	; reset sprungadresse
0022   0002 00          		nop
0023   0003 44 32       _INT		jmp INTERRUPT	; interrupt sprungadresse
0024   0005 00          		nop
0025   0006 00          		nop
0026   0007 44 29       _TINT		jmp TIMERINT	; timer interrupt sprungadresse
0027   0009 00          		nop
0028   000A             
0029   0010             .org 0010h
0030   0010             	; Platz fuer 16 Byte EPROM ID
0031   0010 30 31 32 33 	.byte	"0123456789abcdef"
0031   0014 34 35 36 37 
0031   0018 38 39 61 62 
0031   001C 63 64 65 66 
0032   0020             	
0033   0020             	; ---------------- init --------------------
0034   0020 15          INIT	dis i		; (1 cyc) interrupt verhindern
0035   0021 35          	dis tcnti	; (1 cyc) timer interrupt verhindern
0036   0022 75          	ent0 clk	; (1 cyc) T0 prozessortakt ausgeben
0037   0023             	
0038   0023 34 E3       	call I2CINIT	; init i2c - SDA and SCL high
0039   0025             	
0040   0025 54 24       	call WATCHDOG	; trigger P27
0041   0027             	
0042   0027 34 E6       x0	call I2CSTART	; start I2C sequence
0043   0029             	
0044   0029             	;*** LCD Address
0045   0029 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0046   002B 34 C8       	call I2COUT	; write to I2C
0047   002D             	
0048   002D 34 00       	call INITLCD	; init sequence LCD
0049   002F             	
0050   002F BC 0A       	mov r4,#$0a	; 10*10ms
0051   0031 34 9F       	call wait10	;
0052   0033 54 24       	call WATCHDOG	; trigger P27
0053   0035             	
0054   0035             	
0055   0035 23 08       	mov a,#$08
0056   0037 34 51       	call LCDCGR
0057   0039 23 81       	mov a,#$(%10000001)
0058   003B 34 7D       	call LCDDAT
0059   003D 23 42       	mov a,#$(%01000010)
0060   003F 34 7D       	call LCDDAT
0061   0041 23 24       	mov a,#$(%00100100)
0062   0043 34 7D       	call LCDDAT
0063   0045 23 18       	mov a,#$(%00011000)
0064   0047 34 7D       	call LCDDAT
0065   0049 23 18       	mov a,#$(%00011000)
0066   004B 34 7D       	call LCDDAT
0067   004D 23 04       	mov a,#$(%00000100)
0068   004F 34 7D       	call LCDDAT
0069   0051 23 0A       	mov a,#$(%00001010)
0070   0053 34 7D       	call LCDDAT
0071   0055 23 11       	mov a,#$(%00010001)
0072   0057 34 7D       	call LCDDAT
0073   0059             	
0074   0059 23 45       	mov a,#$45
0075   005B 34 55       	call LCDDDR
0076   005D             	
0077   005D 54 24       	call WATCHDOG	; trigger P27
0078   005F             	
0079   005F             	
0080   005F             	; print text to LCD
0081   005F B9 00       	mov r1,#$00	; set index to 0
0082   0061 F9          p_1	mov a,r1	; lade text index
0083   0062 E3          	movp3 a,@a	; hole zeichen aus P3, index akku
0084   0063 C6 6A       	jz x1		; null byte endekennung?
0085   0065 34 7D       	call LCDDAT	; print chr on LCD
0086   0067 19          	inc r1		; text index++
0087   0068 04 61       	jmp p_1		; naechstes Zeichen
0088   006A             	
0089   006A 34 ED       x1	call I2CSTOP	; stop I2C sequence
0090   006C             	
0091   006C 54 24       x2	call WATCHDOG
0092   006E             	
0093   006E 04 6C       	jmp x2
0094   0070             
0095   0070             
0096   0100             .org $0100
0097   0100             
0098   0100             
0099   0100             ;*****************************************
0100   0100             ; Init sequence LCD 4-bit value
0101   0100             ; A= LCD 8bit-command
0102   0100             ; r5= temp Port expander PCF8574
0103   0100             ;*****************************************
0104   0100             INITLCD	;*** Init Try 1
0105   0100 BD 0C       	mov r5,#EXPWRCMD ; preset for P0-P3 expander, K=1, E=1, RW=0, RS=0
0106   0102 23 30       	mov a,#$(%00110000) ; Function Set #1, DL=1 8bit datalength
0107   0104 34 93       	call LCDCMDI	; write high nibble LCD cmd 
0108   0106             	
0109   0106 34 9F       	call wait10	; 1*10ms
0110   0108 54 24       	call WATCHDOG	; trigger P27
0111   010A             	
0112   010A             	;*** Init Try 2
0113   010A BD 0C       	mov r5,#EXPWRCMD ; preset for P0-P3 expander, K=1, E=1, RW=0, RS=0
0114   010C 23 30       	mov a,#$(%00110000) ; Function Set #2, DL=1 8bit datalength
0115   010E 34 93       	call LCDCMDI	; write high nibble LCD cmd 
0116   0110             	
0117   0110 34 9F       	call wait10	; 1*10ms
0118   0112 54 24       	call WATCHDOG	; trigger P27
0119   0114             	
0120   0114             	;*** Init Try 3
0121   0114 BD 0C       	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0122   0116 23 30       	mov a,#$(%00110000) ; Function Set #3, DL=1 8bit datalength
0123   0118 34 93       	call LCDCMDI	; write high nibble LCD cmd 
0124   011A             	
0125   011A 34 9F       	call wait10	; 1*10ms
0126   011C 54 24       	call WATCHDOG	; trigger P27
0127   011E             	
0128   011E             	; Init set 4bit mode
0129   011E BD 0C       	mov r5,#EXPWRCMD ; preset P0-P3 expander, K=1, E=1, RW=0, RS=0
0130   0120 23 2C       	mov a,#$(%00101100) ; Function Set, DL=0 4bit datalength, E=1, RS=0
0131   0122 34 93       	call LCDCMDI	; write high nibble LCD cmd 
0132   0124             	
0133   0124 34 9F       	call wait10	; 1*10ms
0134   0126 54 24       	call WATCHDOG	; trigger P27
0135   0128             	
0136   0128             	;***** valid Init sequence
0137   0128             	; set 'Function Set'
0138   0128 23 28       	mov a,#$(%00101000) ; Function set: DL=0 4bit, N=1 2lines, F=0 5x7 dots
0139   012A 34 79       	call LCDCMD	; write 8-bit LCD command
0140   012C             	
0141   012C 34 9F       	call wait10	; 1*10ms
0142   012E 54 24       	call WATCHDOG	; trigger P27
0143   0130             	
0144   0130             	; set 'Display Control'
0145   0130 23 0C       	mov a,#$(%00001100) ; display control: D=1 display on, C=0 cursor off, B=0 blink cursor off
0146   0132 34 79       	call LCDCMD	; write 8-bit LCD command
0147   0134             	
0148   0134 34 9F       	call wait10	; 1*10ms
0149   0136 54 24       	call WATCHDOG	; trigger P27
0150   0138             	
0151   0138             	; set 'Clear Control'
0152   0138 23 01       	mov a,#$(%00000001) ; clear display
0153   013A 34 79       	call LCDCMD	; write 8-bit LCD command
0154   013C             	
0155   013C 34 9F       	call wait10	; 1*10ms
0156   013E 54 24       	call WATCHDOG	; trigger P27
0157   0140             	
0158   0140             	; set 'Entry mode'
0159   0140 23 06       	mov a,#$(%00000110) ; entry mode: I/D=1 increment, S=0 with display shift no
0160   0142 34 79       	call LCDCMD	; write 8-bit LCD command
0161   0144             	
0162   0144 34 9F       	call wait10	; 1*10ms
0163   0146 54 24       	call WATCHDOG	; trigger P27
0164   0148             	
0165   0148             	; set 'Cursor At Home'
0166   0148 23 02       	mov a,#$(%00000010) ; 'Cursor At Home'
0167   014A 34 79       	call LCDCMD	; write 8-bit LCD command
0168   014C             	
0169   014C 34 9F       	call wait10	; 1*10ms
0170   014E 54 24       	call WATCHDOG	; trigger P27
0171   0150             	
0172   0150 83          	ret		;bye
0173   0151             
0174   0151             
0175   0151             ;*****************************************
0176   0151             ; Set CG/DD RAM address only, Write LCD 4-bit value
0177   0151             ; A= CG/DD LCD 8bit-RAM address
0178   0151             ; r5= temp Port expander PCF8574
0179   0151             ; r6= temp LCD 8bit-value
0180   0151             ;*****************************************
0181   0151 43 40       LCDCGR	orl a,#$(%01000000)
0182   0153 24 57       	jmp LCDR
0183   0155 43 80       LCDDDR	orl a,#$(%10000000)
0184   0157             	
0185   0157 BD 0C       LCDR	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0186   0159             	
0187   0159             	; set high nibble LCD command
0188   0159 AE          	mov r6,a	; store full 8-bit LCD-value
0189   015A 53 F0       	anl a,#$F0	; cut low nibble from LCD-value
0190   015C 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0191   015D AD          	mov r5,a	; store expander full 8-bit port
0192   015E 34 C8       	call I2COUT	; write to I2C
0193   0160 FD          	mov a,r5	; load expander full 8-bit
0194   0161 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0195   0163 34 C8       	call I2COUT	; write to I2C
0196   0165             	
0197   0165             	; set low nibble LCD command
0198   0165 FE          	mov a,r6	; load full 8-bit LCD-value
0199   0166 47          	swap a		; xchange nibble, low -> high
0200   0167 AE          	mov r6,a	; store modified full 8bit LCD-value
0201   0168 FD          	mov a,r5	; load expander full 8-bit
0202   0169 53 0F       	anl a,#$0f	; extract K, E, RW, RS
0203   016B AD          	mov r5,a	; store P0-P3 expander, (K, E, RW, RS)
0204   016C FE          	mov a,r6	; load full 8-bit LCD-value
0205   016D 53 F0       	anl a,#$F0	; cut low nibble LCD-value
0206   016F 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0207   0170 AD          	mov r5,a	; store expander full 8-bit
0208   0171 34 C8       	call I2COUT	; write to I2C
0209   0173 FD          	mov a,r5	; load expander full 8-bit
0210   0174 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0211   0176 34 C8       	call I2COUT	; write to I2C
0212   0178 83          	ret		; bye
0213   0179             
0214   0179             
0215   0179             ;*****************************************
0216   0179             ; Write LCD 4-bit value
0217   0179             ; A= LCD 8bit-command
0218   0179             ; r5= temp Port expander PCF8574
0219   0179             ; r6= temp LCD 8bit-value
0220   0179             ;*****************************************
0221   0179 BD 0C       LCDCMD	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0222   017B 24 7F       	jmp LCD		;
0223   017D BD 0D       LCDDAT	mov r5,#EXPWRDAT ; P0-P3 expander, K=1, E=1, RW=0, RS=1
0224   017F             	
0225   017F             	; set high nibble LCD command
0226   017F AE          LCD	mov r6,a	; store full 8-bit LCD-value
0227   0180 53 F0       	anl a,#$F0	; cut low nibble from LCD-value
0228   0182 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0229   0183 AD          	mov r5,a	; store expander full 8-bit port
0230   0184 34 C8       	call I2COUT	; write to I2C
0231   0186 FD          	mov a,r5	; load expander full 8-bit
0232   0187 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0233   0189 34 C8       	call I2COUT	; write to I2C
0234   018B             	
0235   018B             	; set low nibble LCD command
0236   018B FE          	mov a,r6	; load full 8-bit LCD-value
0237   018C 47          	swap a		; xchange nibble, low -> high
0238   018D AE          	mov r6,a	; store modified full 8bit LCD-value
0239   018E FD          	mov a,r5	; load expander full 8-bit
0240   018F 53 0F       	anl a,#$0f	; extract K, E, RW, RS
0241   0191 AD          	mov r5,a	; store P0-P3 expander, (K, E, RW, RS)
0242   0192 FE          	mov a,r6	; load full 8-bit LCD-value
0243   0193 53 F0       LCDCMDI	anl a,#$F0	; cut low nibble LCD-value
0244   0195 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0245   0196 AD          	mov r5,a	; store expander full 8-bit
0246   0197 34 C8       	call I2COUT	; write to I2C
0247   0199 FD          	mov a,r5	; load expander full 8-bit
0248   019A 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0249   019C 34 C8       	call I2COUT	; write to I2C
0250   019E 83          	ret		; bye
0251   019F             
0252   019F             
0253   019F             ;;*****************************************
0254   019F             ;; Write LCD 4-bit command
0255   019F             ;; A= LCD 8bit-command
0256   019F             ;; r5= temp Port expander PCF8574
0257   019F             ;; r6= temp LCD 8bit-command
0258   019F             ;;*****************************************
0259   019F             ;LCDCMD
0260   019F             ;	; set high nibble LCD command
0261   019F             ;	mov r6,a	; store 8-bit LCD-CMD
0262   019F             ;	anl a,#$F0	; cut low nibble LCD-CMD
0263   019F             ;	add a,#EXPWRCMD ; add P0-P3 expander, K=1, E=1, RW=0, RS=0
0264   019F             ;	mov r5,a	; store expander 8-bit
0265   019F             ;	call I2COUT	;
0266   019F             ;	mov a,r5	; load expander 8-bit
0267   019F             ;	anl a,#$(%11111011) ; E=0
0268   019F             ;	call I2COUT	;
0269   019F             ;	
0270   019F             ;	; set low nibble LCD command
0271   019F             ;	mov a,r6	; load 8-bit LCD-CMD
0272   019F             ;	swap a		; xchange nibble, low -> high
0273   019F             ;LCDCMDI	anl a,#$F0	; cut low nibble LCD-CMD
0274   019F             ;	add a,#EXPWRCMD	; add P0-P3 expander, K=1, E=1, RW=0, RS=0
0275   019F             ;	mov r5,a	; store expander 8-bit
0276   019F             ;	call I2COUT	;
0277   019F             ;	mov a,r5	; load expander 8-bit
0278   019F             ;	anl a,#$(%11111011) ; E=0
0279   019F             ;	call I2COUT	;
0280   019F             ;	ret		;
0281   019F             ;
0282   019F             ;
0283   019F             ;;*****************************************
0284   019F             ;; Write LCD 4-bit data
0285   019F             ;; A= LCD 8bit-data
0286   019F             ;; r5= temp Port expander PCF8574
0287   019F             ;; r6= temp LCD 8bit-command
0288   019F             ;;*****************************************
0289   019F             ;LCDDAT
0290   019F             ;	; set high nibble LCD command
0291   019F             ;	mov r6,a	; store 8-bit LCD-CMD
0292   019F             ;	anl a,#$F0	; cut low nibble LCD-CMD
0293   019F             ;	add a,#EXPWRDAT ; add P0-P3 expander, K=1, E=1, RW=0, RS=1
0294   019F             ;	mov r5,a	; store expander 8-bit
0295   019F             ;	call I2COUT	;
0296   019F             ;	mov a,r5	; load expander 8-bit
0297   019F             ;	anl a,#$(%11111011) ; E=0
0298   019F             ;	call I2COUT	;
0299   019F             ;	
0300   019F             ;	; set low nibble LCD command
0301   019F             ;	mov a,r6	; load 8-bit LCD-CMD
0302   019F             ;	swap a		; xchange nibble, low -> high
0303   019F             ;	anl a,#$F0	; cut low nibble LCD-CMD
0304   019F             ;	add a,#EXPWRDAT	; add P0-P3 expander, K=1, E=1, RW=0, RS=1
0305   019F             ;	mov r5,a	; store expander 8-bit
0306   019F             ;	call I2COUT	;
0307   019F             ;	mov a,r5	; load expander 8-bit
0308   019F             ;	anl a,#$(%11111011) ; E=0
0309   019F             ;	call I2COUT	;
0310   019F             ;	ret		;
0311   019F             
0312   019F             
0313   019F             ;*****************************************
0314   019F             ; sekunde                                *
0315   019F             ; Da aufwaertszahler, muss die diff zum  *
0316   019F             ; ueberlauf als Wert gtenommen werden    *
0317   019F             ; r4= n * 10ms
0318   019F             ;*****************************************
0319   019F BC 01       wait10		mov r4,#$01	; 1*10ms
0320   01A1 23 B3       wait		mov a,#0b3h	; (1 cyc) 9,895 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0321   01A3 62          		mov t,a		; (1 cyc) timer mit akkuwert laden
0322   01A4 54 24       t_start		call WATCHDOG	;
0323   01A6 55          		strt t		; (1 cyc) timer starten
0324   01A7 16 AB       sek_2		jtf sek_3	; (2 cyc) timer abgelaufen
0325   01A9 24 A7       		jmp sek_2	; (2 cyc) warten bis timer abgelaufen
0326   01AB 65          sek_3		stop tcnt	; (1 cyc) timer anhalten
0327   01AC EC A1       		djnz r4,wait	; (2 cyc) repeat zaehler decrementieren
0328   01AE 83          		ret		; (2 cyc) bye
0329   01AF             
0330   01AF             
0331   01AF             ;*****************************************
0332   01AF             ; I2C read data
0333   01AF             ; SDA & SCL should be low before
0334   01AF             ; r0= temp bitcounter
0335   01AF             ; r3= temp data
0336   01AF             ; A=  data
0337   01AF             ;*****************************************
0338   01AF             I2CIN
0339   01AF             	; SDA & SCL should here be low
0340   01AF B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0341   01B1             	
0342   01B1             	; loop over 8-bit data
0343   01B1             I2CO01	
0344   01B1 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0345   01B3 09          	in a,p1		; read P1x (SDA)
0346   01B4 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0347   01B6             	
0348   01B6 97          	clr c		; C=0
0349   01B7 32 BB       	jb1 I2CO02	; SDA=1 (P1x)
0350   01B9 24 BC       	jmp I2CO03	; SDA=0 (P1x)
0351   01BB A7          I2CO02	cpl c		; C=1
0352   01BC             	
0353   01BC FB          I2CO03	mov a,r3	; lopad temp data
0354   01BD F7          	rlc a		; shift carry into A
0355   01BE AB          	mov r3,a	; save temp data
0356   01BF             	
0357   01BF E8 B1       	djnz r0,I2CO01	; decrement bitcounter,next loop r0>0
0358   01C1             	
0359   01C1             	; check bit-9 AKN/NAKN
0360   01C1 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0361   01C3 09          	in a,p1		; read P1x
0362   01C4 00          	nop		; carry to be define
0363   01C5 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0364   01C7             	
0365   01C7 83          	ret
0366   01C8             
0367   01C8             
0368   01C8             ;*****************************************
0369   01C8             ; I2C write out address/date
0370   01C8             ; SDA & SCL should be low before
0371   01C8             ; data must be stable before and after clock
0372   01C8             ; A= address/data -> R3
0373   01C8             ; r0= temp bitcounter
0374   01C8             ; r3= temp address/data
0375   01C8             ;*****************************************
0376   01C8             I2COUT	; SDA & SCL should here be low
0377   01C8             	
0378   01C8 B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0379   01CA             	
0380   01CA             	; loop over 8-bit adress+RW/data
0381   01CA AB          I2CB01	mov r3,a	; set A to temp adress/data
0382   01CB 97          	clr c		; prerpare carry
0383   01CC FB          	mov a,r3	; load temp adress/data
0384   01CD F7          	rlc a		; shift bit out into carry
0385   01CE F6 D2       	jc I2CB1	; bit set
0386   01D0 24 D4       	jmp I2CB2	; bit clear
0387   01D2 89 02       I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0388   01D4 89 01       I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0389   01D6 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0390   01D8 99 FD       	anl p1,#~(1 << SDA) ; SDA low, bit falling
0391   01DA E8 CA       	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0392   01DC             	
0393   01DC             	; check bit-9 AKN/NAKN
0394   01DC 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0395   01DE 09          	in a,p1		; read P1x
0396   01DF 00          	nop		; carry to be define
0397   01E0 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0398   01E2             	
0399   01E2 83          	ret
0400   01E3             
0401   01E3             
0402   01E3             ;;*****************************************
0403   01E3             ;; I2C write out address/date
0404   01E3             ;; SDA & SCL should be low before
0405   01E3             ;; data must be stable before and after clock
0406   01E3             ;; A= address/data -> R3
0407   01E3             ;; r0= temp bitcounter
0408   01E3             ;; r3= temp address/data
0409   01E3             ;; F0= R/W 1/0
0410   01E3             ;; F1= address/data 1/0
0411   01E3             ;;*****************************************
0412   01E3             ;I2COUT
0413   01E3             ;	mov r0,#$08	; set bitcounter to 8-bit
0414   01E3             ;	jf1 I2CB00	; F1=1 7-bit address mode + 1-bit RW
0415   01E3             ;	jmp I2CB01	; F1=0 8-bit data mode
0416   01E3             ;	
0417   01E3             ;	; adapt to address + R/W
0418   01E3             ;I2CB00	rl a		; convert A to address << 1 and b0=0 (write)
0419   01E3             ;	jf0 I2CB00A	; read mode
0420   01E3             ;	jmp I2CB01	; write mode
0421   01E3             ;I2CB00A	orl a,#$01	; b0=1 (read)
0422   01E3             ;	
0423   01E3             ;	; SDA & SCL should here be low
0424   01E3             ;	; loop over 8-bit adress+RW/data
0425   01E3             ;I2CB01	mov r3,a	; set A to temp adress/data
0426   01E3             ;	clr c		; prerpare carry
0427   01E3             ;	mov a,r3	; load temp adress/data
0428   01E3             ;	rlc a		; shift bit out into carry
0429   01E3             ;	jc I2CB1	; bit set
0430   01E3             ;	jmp I2CB2	; bit clear
0431   01E3             ;I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0432   01E3             ;I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0433   01E3             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0434   01E3             ;	anl p1,#~(1 << SDA) ; SDA low, bit falling
0435   01E3             ;	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0436   01E3             ;	
0437   01E3             ;	; check bit-9 AKN/NAKN
0438   01E3             ;	orl p1,#$(1 << SCL) ; SCL high, clock rising
0439   01E3             ;	in a,p1		; read P1x
0440   01E3             ;	nop		; carry to be define
0441   01E3             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0442   01E3             ;	
0443   01E3             ;	ret
0444   01E3             
0445   01E3             
0446   01E3             ;*****************************************
0447   01E3             ; I2C init sequence
0448   01E3             ;*****************************************
0449   01E3             I2CINIT	
0450   01E3 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0451   01E5 83          	ret
0452   01E6             
0453   01E6             
0454   01E6             ;*****************************************
0455   01E6             ; I2C start sequence
0456   01E6             ; SDA & SCL should be low before
0457   01E6             ;*****************************************
0458   01E6             I2CSTART
0459   01E6 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0460   01E8 99 FD       	anl p1,#~(1 << SDA)		; SDA low, SCL high
0461   01EA 99 FC       	anl p1,#~((1 << SDA)|(1 << SCL)) ; SDA & SCL low
0462   01EC 83          	ret				;
0463   01ED             
0464   01ED             
0465   01ED             ;*****************************************
0466   01ED             ; I2C start sequence
0467   01ED             ; SDA & SCL should be low before
0468   01ED             ;*****************************************
0469   01ED             I2CSTOP
0470   01ED             	;in a,p1
0471   01ED             	;outl p1,a
0472   01ED 89 01       	orl p1,#$(1 << SCL)		; SCL high
0473   01EF 00          	nop
0474   01F0 00          	nop
0475   01F1 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0476   01F3 00          	nop
0477   01F4 83          	ret				;
0478   01F5             
0479   01F5             
0480   0200             .org $0200
0481   0200             
0482   0200              ;************************************************
0483   0200             ; Load SW1/SW2
0484   0200             ; R3/R4= temporary result of SW1/SW2
0485   0200             ; $20= result of SW1
0486   0200             ; $21= result of SW2
0487   0200             ;************************************************
0488   0200             rdSW12:
0489   0200 23 10       	mov	a,#$10		; init value-corunter
0490   0202 AA          	mov	r2,a		; with %00010000
0491   0203             L0332:
0492   0203 FB          	mov	a,r3		; move SW counter from r3
0493   0204 AC          	mov	r4,a		; to SW counter r4
0494   0205             L0334:
0495   0205 CA          	dec	r2		; value-counter r2--
0496   0206 09          	in	a,p1		; load current value of port1
0497   0207 53 F0       	anl	a,#$F0		; cut low nibble
0498   0209 4A          	orl	a,r2		; "add" value-counter r2 into
0499   020A 39          	outl	p1,a		; write back to port1
0500   020B FB          	mov	a,r3		; load A with r3
0501   020C 97          	clr	c		; clear carry
0502   020D 56 10       	jt1	L033F		; SW is "On"?
0503   020F A7          	cpl	c		; set carry (inverted val)
0504   0210             L033F:
0505   0210 F7          	rlc	a		; fill value with carry from right
0506   0211 AB          	mov	r3,a		; store result to counter r3
0507   0212 FA          	mov	a,r2		; load counter r2
0508   0213 72 03       	jb3	L0332		; bit 3 set (SW2 active)?
0509   0215 53 0F       	anl	a,#$0F		; cut high nibble
0510   0217 C6 1B       	jz	L034A		; value-counter clear
0511   0219 44 05       	jmp	L0334		; next loop, SW counter -> r4
0512   021B             L034A:
0513   021B B8 20       	mov	r0,#ZP_SW1	; set index ZP $20
0514   021D FB          	mov	a,r3		; store result from r3
0515   021E A0          	mov	@r0,a		; to RAM $20
0516   021F B8 21       	mov	r0,#ZP_SW2	; set index ZP $21
0517   0221 FC          	mov	a,r4		; store result from r4
0518   0222 A0          	mov	@r0,a		; to RAM $21
0519   0223 83          	ret			; bye
0520   0224             
0521   0224             
0522   0224             ;*****************************************
0523   0224             ; watchdog impuls |_|- high->low -> high *
0524   0224             ; must be execute at least each ~630ms   *
0525   0224             ;*****************************************
0526   0224             WATCHDOG:
0527   0224 9A 7F       	anl p2,#$(~b_WD)	; (2 cyc) P27 Watchdog low
0528   0226 8A 80       	orl p2,#b_WD		; (2 cyc) P27 Watchdog high
0529   0228 83          	ret			; (2 cyc)
0530   0229             
0531   0229             
0532   0229             
0533   0229             ;***********************************************
0534   0229             ; Timer interrupt routine alle 10,02 ms        *
0535   0229             ;***********************************************
0536   0229             TIMERINT:
0537   0229 93          	retr
0538   022A             	
0539   022A             	
0540   022A 23 B3       	mov a,#0b3h		; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0541   022C 62          	mov t,a			; (1 cyc) timer mit akkuwert laden
0542   022D 09          	in a,p1			; (2 cyc) lese port #1 in kku
0543   022E D3 80       	xrl a,#b_WD		; (2 cyc) XOR akku mit bit 7
0544   0230 39          	outl p1,a		; (2 cyc) schreibe akku nach port #1
0545   0231 93          	retr			; (2 cyc) return mit PSW restore
0546   0232             
0547   0232             ;***********************************************
0548   0232             ; interrupt routine                            *
0549   0232             ;***********************************************
0550   0232             INTERRUPT:
0551   0232 93          	retr			;
0552   0233             
0553   0233             
0554   0300             .org $0300
0555   0300             	;      0123456789abcdef
0556   0300 48 61 6C 6C 	.text "Hallo Andreas "
0556   0304 6F 20 41 6E 
0556   0308 64 72 65 61 
0556   030C 73 20 
0557   030E 01          	.byte 01h
0558   030F 02          	.byte 02h
0559   0310 00          	.byte 00h
0560   0311             
0561   0311             
0562   0311             .end
0563   0311             



Type Key: N=NULL_SEG C=CODE_SEG B=BIT_SEG X=EXTD_SEG D=DATA_SEG
          L=Local
          E=Export

Value    Type   Label
-----    ----   ------------------------------
000D     N      CR                              
000C     N      EXPWRCMD                        
000D     N      EXPWRDAT                        
0002     N      E                               
0003     N      IO_CD                           
0004     N      IO_RESET                        
004E     N      I2CLCDWR                        
004F     N      I2CLCDRD                        
0020     N      INIT                            
0100     N      INITLCD                         
01AF     N      I2CIN                           
01B1     N      I2CO01                          
01BB     N      I2CO02                          
01BC     N      I2CO03                          
01C8     N      I2COUT                          
01CA     N      I2CB01                          
01D2     N      I2CB1                           
01D4     N      I2CB2                           
01E3     N      I2CINIT                         
01E6     N      I2CSTART                        
01ED     N      I2CSTOP                         
0232     N      INTERRUPT                       
0003     N      K                               
000A     N      LF                              
0151     N      LCDCGR                          
0155     N      LCDDDR                          
0157     N      LCDR                            
0179     N      LCDCMD                          
017D     N      LCDDAT                          
017F     N      LCD                             
0193     N      LCDCMDI                         
0203     N      L0332                           
0205     N      L0334                           
0210     N      L033F                           
021B     N      L034A                           
0000     N      NUL                             
0000     N      RS                              
0001     N      RW                              
0000     N      SCL                             
0001     N      SDA                             
0229     N      TIMERINT                        
0224     N      WATCHDOG                        
0020     N      ZP_SW1                          
0021     N      ZP_SW2                          
0022     N      ZP_22                           
0023     N      ZP_LNIB                         
0024     N      ZP_HNIB                         
0025     N      ZP_25                           
0026     N      ZP_26                           
0080     N      b_WD                            
0000     NL     noname._RESET                   
0003     NL     noname._INT                     
0007     NL     noname._TINT                    
0061     N      p_1                             
0200     N      rdSW12                          
01A7     N      sek_2                           
01AB     N      sek_3                           
01A4     N      t_start                         
019F     N      wait10                          
01A1     N      wait                            
0027     N      x0                              
006A     N      x1                              
006C     N      x2                              


ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------
0000  04 20 00 44 32 00 00 44 29 00 FF FF FF FF FF FF
0010  30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66
0020  15 35 75 34 E3 54 24 34 E6 23 4E 34 C8 34 00 BC
0030  0A 34 9F 54 24 23 08 34 51 23 81 34 7D 23 42 34
0040  7D 23 24 34 7D 23 18 34 7D 23 18 34 7D 23 04 34
0050  7D 23 0A 34 7D 23 11 34 7D 23 45 34 55 54 24 B9
0060  00 F9 E3 C6 6A 34 7D 19 04 61 34 ED 54 24 04 6C
0070  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0080  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0090  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00A0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00B0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00C0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0100  BD 0C 23 30 34 93 34 9F 54 24 BD 0C 23 30 34 93
0110  34 9F 54 24 BD 0C 23 30 34 93 34 9F 54 24 BD 0C
0120  23 2C 34 93 34 9F 54 24 23 28 34 79 34 9F 54 24
0130  23 0C 34 79 34 9F 54 24 23 01 34 79 34 9F 54 24
0140  23 06 34 79 34 9F 54 24 23 02 34 79 34 9F 54 24
0150  83 43 40 24 57 43 80 BD 0C AE 53 F0 6D AD 34 C8
0160  FD 53 FB 34 C8 FE 47 AE FD 53 0F AD FE 53 F0 6D
0170  AD 34 C8 FD 53 FB 34 C8 83 BD 0C 24 7F BD 0D AE
0180  53 F0 6D AD 34 C8 FD 53 FB 34 C8 FE 47 AE FD 53
0190  0F AD FE 53 F0 6D AD 34 C8 FD 53 FB 34 C8 83 BC
01A0  01 23 B3 62 54 24 55 16 AB 24 A7 65 EC A1 83 B8
01B0  08 89 01 09 99 FE 97 32 BB 24 BC A7 FB F7 AB E8
01C0  B1 89 01 09 00 99 FE 83 B8 08 AB 97 FB F7 F6 D2
01D0  24 D4 89 02 89 01 99 FE 99 FD E8 CA 89 01 09 00
01E0  99 FE 83 89 03 83 89 03 99 FD 99 FC 83 89 01 00
01F0  00 89 03 00 83 FF FF FF FF FF FF FF FF FF FF FF
0200  23 10 AA FB AC CA 09 53 F0 4A 39 FB 97 56 10 A7
0210  F7 AB FA 72 03 53 0F C6 1B 44 05 B8 20 FB A0 B8
0220  21 FC A0 83 9A 7F 8A 80 83 93 23 B3 62 09 D3 80
0230  39 93 93 FF FF FF FF FF FF FF FF FF FF FF FF FF
0240  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0250  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0260  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0270  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0280  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0290  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02A0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02B0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02C0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0300  48 61 6C 6C 6F 20 41 6E 64 72 65 61 73 20 01 02
0310  00 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF


tasm: Number of errors = 0
