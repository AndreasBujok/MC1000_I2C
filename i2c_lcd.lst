0001   0000             
0002   0000             ;************************************************
0003   0000             ; 8039 Quarz = 3,6864 Mhz                       *
0004   0000             ; f = 3,6864 Mhz / 3 = 1,2288 Mhz               *
0005   0000             ; ALE = CLK / 5 = 245,76 kHz = 4,069 us         *
0006   0000             ; TCLK int = ALE / 32 = 7,68 kHz = 130,2083 us  *
0007   0000             ; 1 cyc = 4,069 us                              *
0008   0000             ; 1 timer tick = 130 us                         *
0009   0000             ; Syntax: Telemark TASM Version 3.2             *
0010   0000             ;************************************************
0011   0000             
0012   0000             #include "mc1000.inc";
0001+  0000             
0002+  0000             NUL	= $00	; null value
0003+  0000             CR	= $0d	; Carrage return
0004+  0000             LF	= $0A	; Line feed
0005+  0000             
0006+  0000             b_WD	= $80	; watchdog bit
0007+  0000             
0008+  0000             ZP_SW1	= $20	; result of switch #1 (call rdSW12)
0009+  0000             ZP_SW2	= $21	; result of switch #2 (call rdSW12)
0010+  0000             ZP_22	= $22	; rescue 8b (b82HEX))
0011+  0000             ZP_LNIB	= $23	; low nibble result of 8b
0012+  0000             ZP_HNIB	= $24	; high nibble result of 8b
0013+  0000             ZP_25	= $25	; working nibble result
0014+  0000             ZP_26	= $26	; last pressed raw key 7279
0015+  0000             
0016+  0000             ZP_29	= $29	; start textbuffer (2 x textlength)
0017+  0000             
0018+  0000             
0019+  0000             
0013   0000             #include "io.inc";
0001+  0000             
0002+  0000             
0003+  0000             IO_CD		= $03 ; P13
0004+  0000             IO_RESET	= $04 ; P14, active high
0005+  0000             
0014   0000             #include "i2c.inc";
0001+  0000             
0002+  0000             
0003+  0000             ; Displayram address
0004+  0000             ; 2 x 16 = $00-$0F, $40-$4F
0005+  0000             ; 4 x 20 = $00-$13, $40-$53, $14-$27, $54-$67
0006+  0000             
0007+  0000             
0008+  0000             SCL = 0	; P10
0009+  0000             SDA = 1	; P11
0010+  0000             
0011+  0000             STARTTXTBUF = ZP_29
0015   0000             #include "lcd_i2c.inc";
0001+  0000             
0002+  0000             I2CLCDWR = %01001110
0003+  0000             I2CLCDRD = %01001111
0004+  0000             
0005+  0000             EXPWRCMD = %00001100 ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0006+  0000             EXPWRDAT = %00001101 ; P0-P3 expander, K=1, E=1, RW=0, RS=1
0007+  0000             RS	= 0 ; P0 PCF8574, Register Select
0008+  0000             RW	= 1 ; P1 PCF8574, Read/Write
0009+  0000             E	= 2 ; P2 PCF8574, Enable, commit by falling edge
0010+  0000             K	= 3 ; P3 PCF8574, LCD Backlight, K=1 On, K=0 Off
0011+  0000             
0012+  0000             
0013+  0000             
0016   0000             
0017   0000             #include "macros.inc"
0001+  0000             
0002+  0000             #define LB(x) (x & $FF)
0003+  0000             #define HB(x) (x >> 8)0018   0000             
0019   0000             MAJOR	= 2
0020   0000             MINOR	= 2
0021   0000             
0022   0000             ;*** Values of freerunning timer interrupt
0023   0000             Ttick_10ms = 77 ; 10,02 ms/130 us = 77
0024   0000             Ttick_5ms = 38  ; 4,9 ms /130 us = 38
0025   0000             Ttick_1ms = 8   ; 1,04 ms / 130 us = 8
0026   0000             
0027   0000             Ttime	= Ttick_1ms
0028   0000             TSCALE	= (256 - Ttime) ; TSCALE + Ttime => Timeroverflow (FF -> 00)
0029   0000             
0030   0000             .org 0000h
0031   0000             
0032   0000             
0033   0000 04 21       _RESET		jmp INIT	; reset sprungadresse
0034   0002 00          		nop
0035   0003 84 48       _INT		jmp INTERRUPT	; interrupt sprungadresse
0036   0005 00          		nop
0037   0006 00          		nop
0038   0007 84 38       _TINT		jmp TIMERINT	; timer interrupt sprungadresse
0039   0009 00          		nop
0040   000A             
0041   000A             	; ------- MiniPro EPROM ID 16 Byte ------------
0042   0010             .org 0010h
0043   0010             	; reserved for MiniPro 16 Byte EPROM ID/sertial numbers
0044   0010             	; "2021-02-16 16:23"
0045   0010 32 30 32 31 ROMDAT	.byte	"2021-xx-xx yy:yy"
0045   0014 2D 78 78 2D 
0045   0018 78 78 20 79 
0045   001C 79 3A 79 79 
0046   0020 00          	.byte $00
0047   0021             
0048   0021             
0049   0021             	; ---------------- init --------------------
0050   0021 15          INIT	dis i		; (1 cyc) disable interrupt
0051   0022 25          	en tcnti	; (1 cyc) enable timer interrupt
0052   0023             	
0053   0023 34 C1       	call I2CINIT
0054   0025 23 F8       	mov a,#TSCALE	; load timerinterrupt prescaler
0055   0027 62          	mov t,a		; load timer
0056   0028 55          	strt t		; start timer
0057   0029 75          	ent0 clk	; enable output T0 processor clock
0058   002A             	
0059   002A 34 C4       	call I2CSTART	; I2C start sequence
0060   002C             	
0061   002C             	;*** set LCD Address
0062   002C 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0063   002E 34 A6       	call I2COUT	; write to I2C
0064   0030             	
0065   0030 34 00       	call INITLCD	; run LCD initsequence
0066   0032             	
0067   0032 23 00       	mov a,#$00	; Zeile 0, Pos 0
0068   0034 34 43       	call LCDPOS	; set cursor position
0069   0036 23 00       	mov a,#$LB(LOGO) ; load start of string
0070   0038 14 76       	call PRINTP3LCD	; print on LCD
0071   003A             	
0072   003A 23 40       	mov a,#$40	; Zeile 1, Pos 0
0073   003C 34 43       	call LCDPOS	; set cursor position
0074   003E 23 15       	mov a,#$LB(VERSION) ; load start of string
0075   0040 14 76       	call PRINTP3LCD	; print on LCD
0076   0042 23 02       	mov a,#MAJOR	; load major version number
0077   0044 03 30       	add a,#$30	; convert to ASCII
0078   0046 34 6B       	call LCDDAT	; print single major version on LCD
0079   0048 23 2E       	mov a,#'.'	; load ASCII '.'
0080   004A 34 6B       	call LCDDAT	; print on LCD
0081   004C 23 02       	mov a,#MINOR	; load minor version number
0082   004E 03 30       	add a,#$30	; convert to ASCII
0083   0050 34 6B       	call LCDDAT	; print single minor version on LCD
0084   0052             	
0085   0052 54 29       	call wait10	; wait 10ms
0086   0054             	
0087   0054 23 54       	mov a,#$54	; Zeile 3, Pos 0
0088   0056 34 43       	call LCDPOS	; set cursor position
0089   0058 23 1E       	mov a,#$LB(ROM)	; load start of string
0090   005A 14 76       	call PRINTP3LCD	; print on LCD
0091   005C             	
0092   005C 54 29       	call wait10	; wait 10ms
0093   005E             	
0094   005E 14 83       	call ROMDAT2LCD	; print timestamp of ROM burning
0095   0060             	
0096   0060 54 29       	call wait10	; wait 10ms
0097   0062             	
0098   0062 23 14       	mov a,#$14	; Zeile 2, Pos 0
0099   0064 34 43       	call LCDPOS	; set cursor position
0100   0066 23 23       	mov a,#$LB(TIMERTICK) ; load start of string
0101   0068 14 76       	call PRINTP3LCD	; print on LCD
0102   006A             	
0103   006A 54 29       	call wait10	; wait 10ms
0104   006C             	
0105   006C 23 08       	mov a,#Ttime	; load Ttime
0106   006E 03 30       	add a,#$30	; add P3 textstart
0107   0070 14 76       	call PRINTP3LCD	; print on LCD
0108   0072             	
0109   0072 34 CB       	call I2CSTOP	; I2C stop sequence
0110   0074             	
0111   0074 04 74       	jmp $		; loop to yourself
0112   0076             
0113   0076             
0114   0076             ;*****************************************
0115   0076             ; print string from P3 to LCD            *
0116   0076             ; A= Startaddress of Text within Page3   *
0117   0076             ;*****************************************
0118   0076             PRINTP3LCD
0119   0076 A9          	mov r1,a	; set A to textstart
0120   0077             PP3LCD_1
0121   0077 F9          	mov a,r1	; lade text index
0122   0078 E3          	movp3 a,@a	; hole zeichen aus P3, index akku
0123   0079 C6 82       	jz PP3LCD_2	; null byte endekennung?
0124   007B 34 6B       	call LCDDAT	; print chr on LCD
0125   007D 54 29       	call wait10	; wait 10ms
0126   007F 19          	inc r1		; text index++
0127   0080 04 77       	jmp PP3LCD_1	;
0128   0082             PP3LCD_2
0129   0082 83          	ret		;
0130   0083             
0131   0083             
0132   0083             ;*****************************************
0133   0083             ; print ROM burning date to LCD          *
0134   0083             ; R1= start of string                    *
0135   0083             ;*****************************************
0136   0083             ROMDAT2LCD
0137   0083 B9 10       	mov r1,#ROMDAT	; set A to textstart within Pge3
0138   0085 F9          RD1	mov a,r1	; lade text index
0139   0086 A3          	movp a,@a	; hole zeichen aus ROM, index akku
0140   0087 C6 90       	jz RD2		; null byte endekennung?
0141   0089 34 6B       	call LCDDAT	; print chr on LCD
0142   008B 54 29       	call wait10	; wait 10ms
0143   008D 19          	inc r1		; text index++
0144   008E 04 85       	jmp RD1		; loop
0145   0090 83          RD2	ret		; Bye
0146   0091             
0147   0091             
0148   0100             .org $0100
0149   0100             
0150   0100             
0151   0100             ;*****************************************
0152   0100             ; Init sequence for LCD 4-bit mode       *
0153   0100             ;*****************************************
0154   0100             INITLCD	;*** Init Try 1
0155   0100 BD 0C       	mov r5,#EXPWRCMD ; preset for P0-P3 expander, K=1, E=1, RW=0, RS=0
0156   0102 23 30       	mov a,#$(%00110000) ; Function Set #1, DL=1 8bit datalength
0157   0104 34 81       	call LCDCMDI	; write high nibble LCD cmd 
0158   0106 54 29       	call wait10	; 1*10ms
0159   0108             	
0160   0108             	;*** Init Try 2
0161   0108 BD 0C       	mov r5,#EXPWRCMD ; preset for P0-P3 expander, K=1, E=1, RW=0, RS=0
0162   010A 23 30       	mov a,#$(%00110000) ; Function Set #2, DL=1 8bit datalength
0163   010C 34 81       	call LCDCMDI	; write high nibble LCD cmd 
0164   010E 54 29       	call wait10	; 1*10ms
0165   0110             	
0166   0110             	;*** Init Try 3
0167   0110 BD 0C       	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0168   0112 23 30       	mov a,#$(%00110000) ; Function Set #3, DL=1 8bit datalength
0169   0114 34 81       	call LCDCMDI	; write high nibble LCD cmd 
0170   0116 54 29       	call wait10	; 1*10ms
0171   0118             	
0172   0118             	; Init set 4bit mode
0173   0118 BD 0C       	mov r5,#EXPWRCMD ; preset P0-P3 expander, K=1, E=1, RW=0, RS=0
0174   011A 23 2C       	mov a,#$(%00101100) ; Function Set, DL=0 4bit datalength, E=1, RS=0
0175   011C 34 81       	call LCDCMDI	; write high nibble LCD cmd 
0176   011E 54 29       	call wait10	; 1*10ms
0177   0120             	
0178   0120             	;***** start valid Init sequence
0179   0120             	; set 'Function Set'
0180   0120 23 28       	mov a,#$(%00101000) ; Function set: DL=0 4bit, N=1 2lines, F=0 5x7 dots
0181   0122 34 67       	call LCDCMD	; write 8-bit LCD command
0182   0124 54 29       	call wait10	; 1*10ms
0183   0126             	
0184   0126             	; set 'Display Control'
0185   0126 23 0C       	mov a,#$(%00001100) ; display control: D=1 display on, C=0 cursor off, B=0 blink cursor off
0186   0128 34 67       	call LCDCMD	; write 8-bit LCD command
0187   012A 54 29       	call wait10	; 1*10ms
0188   012C             	
0189   012C             	; set 'Clear Control'
0190   012C 23 01       	mov a,#$(%00000001) ; clear display
0191   012E 34 67       	call LCDCMD	; write 8-bit LCD command
0192   0130 54 29       	call wait10	; 1*10ms
0193   0132             	
0194   0132             	; set 'Entry mode'
0195   0132 23 06       	mov a,#$(%00000110) ; entry mode: I/D=1 increment, S=0 with display shift no
0196   0134 34 67       	call LCDCMD	; write 8-bit LCD command
0197   0136 54 29       	call wait10	; 1*10ms
0198   0138             	
0199   0138             	; set 'Cursor At Home'
0200   0138 23 02       	mov a,#$(%00000010) ; 'Cursor At Home'
0201   013A 34 67       	call LCDCMD	; write 8-bit LCD command
0202   013C 54 29       	call wait10	; 1*10ms
0203   013E             	
0204   013E 83          	ret		;bye
0205   013F             
0206   013F             
0207   013F             ;*****************************************
0208   013F             ; Set CG/DD RAM address only, Write LCD 4-bit value
0209   013F             ; A= CG/DD LCD 8bit-RAM address ($00 - $7F) only 
0210   013F             ; r5= temp Port expander PCF8574
0211   013F             ; r6= temp LCD 8bit-value
0212   013F             ;*****************************************
0213   013F 43 40       LCDCGR	orl a,#$(%01000000) ; set CG RAM
0214   0141 24 45       	jmp LCDR
0215   0143 43 80       LCDPOS	orl a,#$(%10000000) ; set DD RAM
0216   0145             	
0217   0145 BD 0C       LCDR	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0218   0147             	
0219   0147             	; set high nibble LCD command
0220   0147 AE          	mov r6,a	; store full 8-bit LCD-value
0221   0148 53 F0       	anl a,#$F0	; cut low nibble from LCD-value
0222   014A 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0223   014B AD          	mov r5,a	; store expander full 8-bit port
0224   014C 34 A6       	call I2COUT	; write to I2C
0225   014E FD          	mov a,r5	; load expander full 8-bit
0226   014F 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0227   0151 34 A6       	call I2COUT	; write to I2C
0228   0153             	
0229   0153             	; set low nibble LCD command
0230   0153 FE          	mov a,r6	; load full 8-bit LCD-value
0231   0154 47          	swap a		; xchange nibble, low -> high
0232   0155 AE          	mov r6,a	; store modified full 8bit LCD-value
0233   0156 FD          	mov a,r5	; load expander full 8-bit
0234   0157 53 0F       	anl a,#$0f	; extract K, E, RW, RS
0235   0159 AD          	mov r5,a	; store P0-P3 expander, (K, E, RW, RS)
0236   015A FE          	mov a,r6	; load full 8-bit LCD-value
0237   015B 53 F0       	anl a,#$F0	; cut low nibble LCD-value
0238   015D 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0239   015E AD          	mov r5,a	; store expander full 8-bit
0240   015F 34 A6       	call I2COUT	; write to I2C
0241   0161 FD          	mov a,r5	; load expander full 8-bit
0242   0162 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0243   0164 34 A6       	call I2COUT	; write to I2C
0244   0166 83          	ret		; bye
0245   0167             
0246   0167             
0247   0167             ;*****************************************
0248   0167             ; Write LCD 4-bit value
0249   0167             ; A= LCD 8bit-command
0250   0167             ; r5= temp Port expander PCF8574
0251   0167             ; r6= temp LCD 8bit-value
0252   0167             ;*****************************************
0253   0167 BD 0C       LCDCMD	mov r5,#EXPWRCMD ; P0-P3 expander, K=1, E=1, RW=0, RS=0
0254   0169 24 6D       	jmp LCD		;
0255   016B BD 0D       LCDDAT	mov r5,#EXPWRDAT ; P0-P3 expander, K=1, E=1, RW=0, RS=1
0256   016D             	
0257   016D             	; set high nibble LCD command
0258   016D AE          LCD	mov r6,a	; store full 8-bit LCD-value
0259   016E 53 F0       	anl a,#$F0	; cut low nibble from LCD-value
0260   0170 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0261   0171 AD          	mov r5,a	; store expander full 8-bit port
0262   0172 34 A6       	call I2COUT	; write to I2C
0263   0174 FD          	mov a,r5	; load expander full 8-bit
0264   0175 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0265   0177 34 A6       	call I2COUT	; write to I2C
0266   0179             	
0267   0179             	; set low nibble LCD command
0268   0179 FE          	mov a,r6	; load full 8-bit LCD-value
0269   017A 47          	swap a		; xchange nibble, low -> high
0270   017B AE          	mov r6,a	; store modified full 8bit LCD-value
0271   017C FD          	mov a,r5	; load expander full 8-bit
0272   017D 53 0F       	anl a,#$0f	; extract K, E, RW, RS
0273   017F AD          	mov r5,a	; store P0-P3 expander, (K, E, RW, RS)
0274   0180 FE          	mov a,r6	; load full 8-bit LCD-value
0275   0181 53 F0       LCDCMDI	anl a,#$F0	; cut low nibble LCD-value
0276   0183 6D          	add a,r5	; add P0-P3 expander, (K, E, RW, RS)
0277   0184 AD          	mov r5,a	; store expander full 8-bit
0278   0185 34 A6       	call I2COUT	; write to I2C
0279   0187 FD          	mov a,r5	; load expander full 8-bit
0280   0188 53 FB       	anl a,#$(%11111011) ; falling edge E=0
0281   018A 34 A6       	call I2COUT	; write to I2C
0282   018C 83          	ret		; bye
0283   018D             
0284   018D             
0285   018D             ;*****************************************
0286   018D             ; I2C read data
0287   018D             ; SDA & SCL should be low before
0288   018D             ; r0= temp bitcounter
0289   018D             ; r3= temp data
0290   018D             ; A=  data
0291   018D             ;*****************************************
0292   018D             I2CIN
0293   018D             	; SDA & SCL should here be low
0294   018D B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0295   018F             	
0296   018F             	; loop over 8-bit data
0297   018F             I2CO01	
0298   018F 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0299   0191 09          	in a,p1		; read P1x (SDA)
0300   0192 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0301   0194             	
0302   0194 97          	clr c		; C=0
0303   0195 32 99       	jb1 I2CO02	; SDA=1 (P1x)
0304   0197 24 9A       	jmp I2CO03	; SDA=0 (P1x)
0305   0199 A7          I2CO02	cpl c		; C=1
0306   019A             	
0307   019A FB          I2CO03	mov a,r3	; lopad temp data
0308   019B F7          	rlc a		; shift carry into A
0309   019C AB          	mov r3,a	; save temp data
0310   019D             	
0311   019D E8 8F       	djnz r0,I2CO01	; decrement bitcounter,next loop r0>0
0312   019F             	
0313   019F             	; check bit-9 AKN/NAKN
0314   019F 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0315   01A1 09          	in a,p1		; read P1x
0316   01A2 00          	nop		; carry to be define
0317   01A3 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0318   01A5             	
0319   01A5 83          	ret
0320   01A6             
0321   01A6             
0322   01A6             ;*****************************************
0323   01A6             ; I2C write out address/date
0324   01A6             ; SDA & SCL should be low before
0325   01A6             ; data must be stable before and after clock
0326   01A6             ; A= address/data -> R3
0327   01A6             ; r0= temp bitcounter
0328   01A6             ; r3= temp address/data
0329   01A6             ;*****************************************
0330   01A6             I2COUT	; SDA & SCL should here be low
0331   01A6             	
0332   01A6 B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0333   01A8             	
0334   01A8             	; loop over 8-bit adress+RW/data
0335   01A8 AB          I2CB01	mov r3,a	; set A to temp adress/data
0336   01A9 97          	clr c		; prerpare carry
0337   01AA FB          	mov a,r3	; load temp adress/data
0338   01AB F7          	rlc a		; shift bit out into carry
0339   01AC F6 B0       	jc I2CB1	; bit set
0340   01AE 24 B2       	jmp I2CB2	; bit clear
0341   01B0 89 02       I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0342   01B2 89 01       I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0343   01B4 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0344   01B6 99 FD       	anl p1,#~(1 << SDA) ; SDA low, bit falling
0345   01B8 E8 A8       	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0346   01BA             	
0347   01BA             	; check bit-9 AKN/NAKN
0348   01BA 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0349   01BC 09          	in a,p1		; read P1x
0350   01BD 00          	nop		; result of AKN/NAKN TBD
0351   01BE 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0352   01C0             	
0353   01C0 83          	ret		; Bye
0354   01C1             
0355   01C1             
0356   01C1             ;*****************************************
0357   01C1             ; I2C init sequence
0358   01C1             ;*****************************************
0359   01C1             I2CINIT	
0360   01C1 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0361   01C3 83          	ret		; Bye
0362   01C4             
0363   01C4             
0364   01C4             ;*****************************************
0365   01C4             ; I2C start sequence
0366   01C4             ;*****************************************
0367   01C4             I2CSTART
0368   01C4 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0369   01C6 99 FD       	anl p1,#~(1 << SDA)	; SDA low, SCL high
0370   01C8 99 FC       	anl p1,#~((1 << SDA)|(1 << SCL)) ; SDA & SCL low
0371   01CA 83          	ret		; Bye
0372   01CB             
0373   01CB             
0374   01CB             ;*****************************************
0375   01CB             ; I2C stop sequence
0376   01CB             ;*****************************************
0377   01CB             I2CSTOP
0378   01CB 89 01       	orl p1,#$(1 << SCL)	; SCL high
0379   01CD 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0380   01CF 83          	ret		; Bye
0381   01D0             
0382   01D0             
0383   0200             .org $0200
0384   0200             
0385   0200              ;************************************************
0386   0200             ; Load SW1/SW2
0387   0200             ; R3/R4= temporary result of SW1/SW2
0388   0200             ; P10-13= used for address counting
0389   0200             ; $20= result of SW1
0390   0200             ; $21= result of SW2
0391   0200             ;************************************************
0392   0200             rdSW12:
0393   0200 23 10       	mov	a,#$10		; init value-corunter
0394   0202 AA          	mov	r2,a		; with %00010000
0395   0203             L0332:
0396   0203 FB          	mov	a,r3		; move SW counter from r3
0397   0204 AC          	mov	r4,a		; to SW counter r4
0398   0205             L0334:
0399   0205 CA          	dec	r2		; value-counter r2--
0400   0206 09          	in	a,p1		; load current value of port1
0401   0207 53 F0       	anl	a,#$F0		; cut low nibble
0402   0209 4A          	orl	a,r2		; "add" value-counter r2 into
0403   020A 39          	outl	p1,a		; write back to port1
0404   020B FB          	mov	a,r3		; load A with r3
0405   020C 97          	clr	c		; clear carry
0406   020D 56 10       	jt1	L033F		; SW is "On"?
0407   020F A7          	cpl	c		; set carry (inverted val)
0408   0210             L033F:
0409   0210 F7          	rlc	a		; fill value with carry from right
0410   0211 AB          	mov	r3,a		; store result to counter r3
0411   0212 FA          	mov	a,r2		; load counter r2
0412   0213 72 03       	jb3	L0332		; bit 3 set (SW2 active)?
0413   0215 53 0F       	anl	a,#$0F		; cut high nibble
0414   0217 C6 1B       	jz	L034A		; value-counter clear
0415   0219 44 05       	jmp	L0334		; next loop, SW counter -> r4
0416   021B             L034A:
0417   021B B8 20       	mov	r0,#ZP_SW1	; set index ZP $20
0418   021D FB          	mov	a,r3		; store result from r3
0419   021E A0          	mov	@r0,a		; to RAM $20
0420   021F B8 21       	mov	r0,#ZP_SW2	; set index ZP $21
0421   0221 FC          	mov	a,r4		; store result from r4
0422   0222 A0          	mov	@r0,a		; to RAM $21
0423   0223 83          	ret			; bye
0424   0224             
0425   0224             
0426   0224             ;*****************************************
0427   0224             ; watchdog impuls |_|- high->low -> high *
0428   0224             ; must be execute at least each ~630ms   *
0429   0224             ;*****************************************
0430   0224             WATCHDOG:
0431   0224 9A 7F       	anl p2,#$(~b_WD)	; (2 cyc) P27 Watchdog low
0432   0226 8A 80       	orl p2,#b_WD		; (2 cyc) P27 Watchdog high
0433   0228 83          	ret			; (2 cyc)
0434   0229             
0435   0229             
0436   0229             ;*****************************************
0437   0229             ; wait 10ms                              *
0438   0229             ; r7 = 1 * 10ms                          *
0439   0229             ;*****************************************
0440   0229 23 09       wait10		mov a,#$(Ttick_10ms / Ttime) ; set timer counter
0441   022B AF          		mov r7,a
0442   022C FF          wait10a		mov a,r7	; load timer counter, decrement on each TimerInt
0443   022D 96 2C       		jnz wait10a	; loop until zero
0444   022F 83          		ret		; Bye
0445   0230             
0446   0230             
0447   0230             
0448   0300             .org $0300
0449   0300             
0450   0300             ;************************************************
0451   0300             ; load textfile for strings on page3
0452   0300             ;************************************************
0453   0300             #include "text.inc";
0001+  0300             
0002+  0300             .org $0300
0003+  0300             ; text on Page3
0004+  0300                          ; 01234567890123456709
0005+  0300 4D 43 31 30 LOGO	.text "MC1000 i2c_lcd.src  "
0005+  0304 30 30 20 69 
0005+  0308 32 63 5F 6C 
0005+  030C 63 64 2E 73 
0005+  0310 72 63 20 20 
0006+  0314 00          	.byte $00
0007+  0315             
0008+  0315 56 65 72 73 VERSION	.text "Version "
0008+  0319 69 6F 6E 20 
0009+  031D 00          	.byte $00
0010+  031E             
0011+  031E 52 4F 4D 20 ROM	.text "ROM "
0012+  0322 00          	.byte $00
0013+  0323             
0014+  0323             TIMERTICK
0015+  0323 54 69 6D 65 	.text "Timertick: "
0015+  0327 72 74 69 63 
0015+  032B 6B 3A 20 
0016+  032E 00          	.byte $00
0017+  032F             	
0018+  032F             
0019+  0338             .org $0330 + Ttick_1ms
0020+  0338 31 20 6D 73 	.text "1 ms"
0021+  033C 00          	.byte $00
0022+  033D             
0023+  0356             .org $0330 + Ttick_5ms
0024+  0356 35 20 6D 73 	.text "5 ms"
0025+  035A 00          	.byte $00
0026+  035B             
0027+  037D             .org $0330 + Ttick_10ms
0028+  037D 31 30 20 6D 	.text "10 ms"
0028+  0381 73 
0029+  0382 00          	.byte $000454   0383             
0455   0383             
0456   0400             .org $0400
0457   0400             
0458   0400             ;************************************************
0459   0400             ; convert 8bit to ASCII Hex
0460   0400             ; A= 8bit value
0461   0400             ; r0= temp value
0462   0400             ; $22= rescued val of 8bit
0463   0400             ; $23= low nibble 0-F
0464   0400             ; $24= high nibble 0-F
0465   0400             ; $25= temp working nibble result
0466   0400             ;************************************************
0467   0400             b82HEX:
0468   0400 B8 22       	mov	r0,#ZP_22	; set index
0469   0402 A0          	mov	@r0,a		; rescue 8b value to RAM $22
0470   0403 53 F0       	anl	a,#$F0		; cut low nibble
0471   0405 47          	swap	a		; swap nibble to create low nibble
0472   0406 B8 25       	mov	r0,#ZP_25	; save nibble result
0473   0408 A0          	mov	@r0,a		; to RAM $25
0474   0409 03 F6       	add	a,#$F6		; A = 0-9?
0475   040B F6 17       	jc	L03B5		; A = A-F?
0476   040D B8 25       	mov	r0,#ZP_25	; read nibble result
0477   040F F0          	mov	a,@r0		; from RAM $25
0478   0410 03 30       	add	a,#$30		; add '0'
0479   0412 B8 24       	mov	r0,#ZP_HNIB	; save 0-9 result
0480   0414 A0          	mov	@r0,a		; in RAM $23
0481   0415 84 1C       	jmp	L03BA		; check 8b low nibble
0482   0417 03 41       L03B5:	add	a,#$41		; add 'A'
0483   0419 B8 24       	mov	r0,#ZP_HNIB	; save A-F result
0484   041B A0          	mov	@r0,a		; in RAM $23
0485   041C             L03BA:
0486   041C B8 22       	mov	r0,#ZP_22	; load rescued value
0487   041E F0          	mov	a,@r0		; from RAM $22
0488   041F 53 0F       	anl	a,#$0F		; cut high nibble
0489   0421 B8 25       	mov	r0,#ZP_25	; save nibble result
0490   0423 A0          	mov	@r0,a		;  to RAM $25
0491   0424 03 F6       	add	a,#$F6		; A = 0-9?
0492   0426 F6 32       	jc	L03D0		; A = A-F?
0493   0428 B8 25       	mov	r0,#ZP_25	; read nibble result
0494   042A F0          	mov	a,@r0		; from RAM $25
0495   042B 03 30       	add	a,#$30		; add '0'
0496   042D B8 23       	mov	r0,#ZP_LNIB	; save 0-9 result
0497   042F A0          	mov	@r0,a		; in RAM $24
0498   0430 84 37       	jmp	L03D5		; jump to RET
0499   0432 03 41       L03D0:	add	a,#$41		; add 'A'
0500   0434 B8 23       	mov	r0,#ZP_LNIB	; save A-F result
0501   0436 A0          	mov	@r0,a		; in RAM $24
0502   0437             L03D5:
0503   0437 83          	ret			;
0504   0438             
0505   0438             
0506   0438             ;*****************************************************
0507   0438             ; Timer interrupt routine, call every timer overflow *
0508   0438             ; decrement r7 until zero on each interrup           *
0509   0438             ;*****************************************************
0510   0438             TIMERINT:
0511   0438 D5          	sel rb1		; switch to registerbank #1
0512   0439 AE          	mov r6,a	; rescue akku on registerbank #1
0513   043A C5          	sel rb0		; switch to registerbank #0
0514   043B 23 F8       	mov a,#TSCALE	; load timer prescale
0515   043D 62          	mov t,a		; set timer
0516   043E FF          	mov a,r7	; load timertick register
0517   043F C6 42       	jz TIMERINT0	; timer register zero?
0518   0441 CF          	dec r7		; r7-- decremt timertick register on interrupt/overflow
0519   0442             TIMERINT0:
0520   0442 54 24       	call WATCHDOG	; P27
0521   0444 D5          	sel rb1		; switch to registerbank #1
0522   0445 FE          	mov a,r6	; restore akku back from registerbank #1
0523   0446 C5          	sel rb0		; switch to registerbank #0
0524   0447 93          	retr		;
0525   0448             
0526   0448             
0527   0448             ;***********************************************
0528   0448             ; interrupt routine                            *
0529   0448             ;***********************************************
0530   0448             INTERRUPT:
0531   0448             	
0532   0448 93          	retr		; (2 cyc) return mit PSW restore
0533   0449             
0534   0449             
0535   0449             ;**************************************************
0536   0449             ; place for comment out uf code snippets/routines *
0537   0449             ;**************************************************
0538   0449             ;
0539   0449             ;	mov a,#Ttime	; load Ttime
0540   0449             ;	call b82HEX	; convert 8bit into ASCII Hex
0541   0449             ;	mov r0,#$24	; result high nible
0542   0449             ;	mov a,@r0	; load high nibble
0543   0449             ;	call LCDDAT	; print ASCII 0-F on LCD
0544   0449             ;	call wait10	; wait 10ms
0545   0449             ;	mov r0,#$23	; result low nibble
0546   0449             ;	mov a,@r0	; low nibble
0547   0449             ;	call LCDDAT	; print ASCII 0-F on LCD
0548   0449             ;
0549   0449             ;	;*** create textbuffer (size = double of textlength)
0550   0449             ;	; calculate buffer and clrear with whitespace
0551   0449             ;	mov a,#$(LOGO_E - LOGO)
0552   0449             ;	rl a		; make double of textlength
0553   0449             ;	add a,#$STARTTXTBUF ; add address of buffer start
0554   0449             ;	mov r0,a	; store indexcounter max of textbuffer
0555   0449             ;ab0	mov @r0,#' '	; fill whitespace into complete textbuffer
0556   0449             ;	djnz r0,ab0	; index r0--
0557   0449             ;	
0558   0449             ;	; write text into start of textbuffer
0559   0449             ;	mov r0,#$STARTTXTBUF ; set index to start of textbuffer
0560   0449             ;	mov r1,#$0300 - LOGO ; set index to start of text in ROM
0561   0449             ;ab01	mov a,r1	; lade text index
0562   0449             ;	movp3 a,@a	; get char from Page3 of ROM
0563   0449             ;	jz ab2		; zero byte - end of text?
0564   0449             ;	mov @r0,a	; store char into RAM buffer
0565   0449             ;	inc r0		; increment index textbuffer
0566   0449             ;	inc r1		; incremwent index text ROM
0567   0449             ;	jmp ab01	; loop next chr
0568   0449             ;ab2	
0569   0449             
0570   0449             ;	; print buffer text to LCD
0571   0449             ;	sel rb1
0572   0449             ;	mov r4,#$00	; set bufferpointer to start
0573   0449             ;	mov r1,#$(LOGO_E - LOGO) ; set length of loop
0574   0449             ;	mov r2,#$00	; startindex each loop
0575   0449             ;	
0576   0449             ;ab10	sel rb0
0577   0449             ;	mov a,#$00
0578   0449             ;	call LCDPOS	; set cursor to Address $00
0579   0449             ;	sel rb1
0580   0449             ;	
0581   0449             ;	
0582   0449             ;	mov r5,#$(LOGO_E - LOGO) ; set length of text
0583   0449             ;	
0584   0449             ;ab11	mov a,r4	; load buffer index
0585   0449             ;	add a,#$STARTTXTBUF ; add buffer startaddress RAM
0586   0449             ;	mov r0,a	; store bufferaddress pointer t0 r0
0587   0449             ;	mov a,@r0	; get char from buffer by r0
0588   0449             ;	
0589   0449             ;	sel rb0
0590   0449             ;	call LCDDAT	; print chr on LCD
0591   0449             ;	call wait10
0592   0449             ;	call wait10
0593   0449             ;	call wait10
0594   0449             ;	sel rb1
0595   0449             ;	
0596   0449             ;	inc r4		; buffer pointer++
0597   0449             ;	djnz r5,ab11	; textlength--
0598   0449             ;	
0599   0449             ;	inc r2		; startindex++
0600   0449             ;	mov a,r2	; move startindex
0601   0449             ;	mov r4,a	; to index startbuffer
0602   0449             ;	djnz r1,ab10
0603   0449             ;	
0604   0449             ;	sel rb0
0605   0449             	
0606   0449             	
0607   0449             ;	; print text to LCD
0608   0449             ;	mov r1,#$0300 - LOGO	; set index to 0
0609   0449             ;p_1	mov a,r1	; lade text index
0610   0449             ;	movp3 a,@a	; hole zeichen aus P3, index akku
0611   0449             ;	jz x1		; null byte endekennung?
0612   0449             ;	call LCDDAT	; print chr on LCD
0613   0449             ;	
0614   0449             ;	mov r7,#01	; set timercounter 25 * 10 ms = 250ms
0615   0449             ;wait0	mov a,r7	; check timercounter
0616   0449             ;	jnz wait0	; loop until zero
0617   0449             ;	
0618   0449             ;x00	inc r1		; text index++
0619   0449             ;	jmp p_1		; loop next character
0620   0449             	
0621   0449             ;x1	mov a,#MAJOR
0622   0449             ;	add a,#$30
0623   0449             ;	call LCDDAT	; print chr on LCD
0624   0449             ;	mov a,#'.'
0625   0449             ;	call LCDDAT	; print chr on LCD
0626   0449             ;	mov a,#MINOR
0627   0449             ;	add a,#$30
0628   0449             ;	call LCDDAT	; print chr on LCD
0629   0449             ;	
0630   0449             ;	call I2CSTOP	; stop I2C sequence
0631   0449             ;	
0632   0449             ;x2	nop		;
0633   0449             ;	jmp x2
0634   0449             
0635   0449             
0636   0449             ; write bitmap into CGRAM
0637   0449             ;	mov a,#$08
0638   0449             ;	call LCDCGR
0639   0449             ;	mov a,#$(%10000001)
0640   0449             ;	call LCDDAT
0641   0449             ;	mov a,#$(%01000010)
0642   0449             ;	call LCDDAT
0643   0449             ;	mov a,#$(%00100100)
0644   0449             ;	call LCDDAT
0645   0449             ;	mov a,#$(%00011000)
0646   0449             ;	call LCDDAT
0647   0449             ;	mov a,#$(%00011000)
0648   0449             ;	call LCDDAT
0649   0449             ;	mov a,#$(%00000100)
0650   0449             ;	call LCDDAT
0651   0449             ;	mov a,#$(%00001010)
0652   0449             ;	call LCDDAT
0653   0449             ;	mov a,#$(%00010001)
0654   0449             ;	call LCDDAT
0655   0449             
0656   0449             
0657   0449             .end
0658   0449             



Type Key: N=NULL_SEG C=CODE_SEG B=BIT_SEG X=EXTD_SEG D=DATA_SEG
          L=Local
          E=Export

Value    Type   Label
-----    ----   ------------------------------
000D     N      CR                              
000C     N      EXPWRCMD                        
000D     N      EXPWRDAT                        
0002     N      E                               
0003     N      IO_CD                           
0004     N      IO_RESET                        
004E     N      I2CLCDWR                        
004F     N      I2CLCDRD                        
0021     N      INIT                            
0100     N      INITLCD                         
018D     N      I2CIN                           
018F     N      I2CO01                          
0199     N      I2CO02                          
019A     N      I2CO03                          
01A6     N      I2COUT                          
01A8     N      I2CB01                          
01B0     N      I2CB1                           
01B2     N      I2CB2                           
01C1     N      I2CINIT                         
01C4     N      I2CSTART                        
01CB     N      I2CSTOP                         
0448     N      INTERRUPT                       
0003     N      K                               
000A     N      LF                              
013F     N      LCDCGR                          
0143     N      LCDPOS                          
0145     N      LCDR                            
0167     N      LCDCMD                          
016B     N      LCDDAT                          
016D     N      LCD                             
0181     N      LCDCMDI                         
0203     N      L0332                           
0205     N      L0334                           
0210     N      L033F                           
021B     N      L034A                           
0300     N      LOGO                            
0417     N      L03B5                           
041C     N      L03BA                           
0432     N      L03D0                           
0437     N      L03D5                           
0002     N      MAJOR                           
0002     N      MINOR                           
0000     N      NUL                             
0076     N      PRINTP3LCD                      
0077     N      PP3LCD_1                        
0082     N      PP3LCD_2                        
0000     N      RS                              
0001     N      RW                              
0010     N      ROMDAT                          
0083     N      ROMDAT2LCD                      
0085     N      RD1                             
0090     N      RD2                             
031E     N      ROM                             
0000     N      SCL                             
0001     N      SDA                             
0029     N      STARTTXTBUF                     
004D     N      Ttick_10ms                      
0026     N      Ttick_5ms                       
0008     N      Ttick_1ms                       
0008     N      Ttime                           
00F8     N      TSCALE                          
0323     N      TIMERTICK                       
0438     N      TIMERINT                        
0442     N      TIMERINT0                       
0315     N      VERSION                         
0224     N      WATCHDOG                        
0020     N      ZP_SW1                          
0021     N      ZP_SW2                          
0022     N      ZP_22                           
0023     N      ZP_LNIB                         
0024     N      ZP_HNIB                         
0025     N      ZP_25                           
0026     N      ZP_26                           
0029     N      ZP_29                           
0080     N      b_WD                            
0400     N      b82HEX                          
0000     NL     noname._RESET                   
0003     NL     noname._INT                     
0007     NL     noname._TINT                    
0200     N      rdSW12                          
0229     N      wait10                          
022C     N      wait10a                         


ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------
0000  04 21 00 84 48 00 00 84 38 00 FF FF FF FF FF FF
0010  32 30 32 31 2D 78 78 2D 78 78 20 79 79 3A 79 79
0020  00 15 25 34 C1 23 F8 62 55 75 34 C4 23 4E 34 A6
0030  34 00 23 00 34 43 23 00 14 76 23 40 34 43 23 15
0040  14 76 23 02 03 30 34 6B 23 2E 34 6B 23 02 03 30
0050  34 6B 54 29 23 54 34 43 23 1E 14 76 54 29 14 83
0060  54 29 23 14 34 43 23 23 14 76 54 29 23 08 03 30
0070  14 76 34 CB 04 74 A9 F9 E3 C6 82 34 6B 54 29 19
0080  04 77 83 B9 10 F9 A3 C6 90 34 6B 54 29 19 04 85
0090  83 FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00A0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00B0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00C0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0100  BD 0C 23 30 34 81 54 29 BD 0C 23 30 34 81 54 29
0110  BD 0C 23 30 34 81 54 29 BD 0C 23 2C 34 81 54 29
0120  23 28 34 67 54 29 23 0C 34 67 54 29 23 01 34 67
0130  54 29 23 06 34 67 54 29 23 02 34 67 54 29 83 43
0140  40 24 45 43 80 BD 0C AE 53 F0 6D AD 34 A6 FD 53
0150  FB 34 A6 FE 47 AE FD 53 0F AD FE 53 F0 6D AD 34
0160  A6 FD 53 FB 34 A6 83 BD 0C 24 6D BD 0D AE 53 F0
0170  6D AD 34 A6 FD 53 FB 34 A6 FE 47 AE FD 53 0F AD
0180  FE 53 F0 6D AD 34 A6 FD 53 FB 34 A6 83 B8 08 89
0190  01 09 99 FE 97 32 99 24 9A A7 FB F7 AB E8 8F 89
01A0  01 09 00 99 FE 83 B8 08 AB 97 FB F7 F6 B0 24 B2
01B0  89 02 89 01 99 FE 99 FD E8 A8 89 01 09 00 99 FE
01C0  83 89 03 83 89 03 99 FD 99 FC 83 89 01 89 03 83
01D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
01F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0200  23 10 AA FB AC CA 09 53 F0 4A 39 FB 97 56 10 A7
0210  F7 AB FA 72 03 53 0F C6 1B 44 05 B8 20 FB A0 B8
0220  21 FC A0 83 9A 7F 8A 80 83 23 09 AF FF 96 2C 83
0230  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0240  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0250  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0260  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0270  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0280  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0290  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02A0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02B0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02C0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
02F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0300  4D 43 31 30 30 30 20 69 32 63 5F 6C 63 64 2E 73
0310  72 63 20 20 00 56 65 72 73 69 6F 6E 20 00 52 4F
0320  4D 20 00 54 69 6D 65 72 74 69 63 6B 3A 20 00 FF
0330  FF FF FF FF FF FF FF FF 31 20 6D 73 00 FF FF FF
0340  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0350  FF FF FF FF FF FF 35 20 6D 73 00 FF FF FF FF FF
0360  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0370  FF FF FF FF FF FF FF FF FF FF FF FF FF 31 30 20
0380  6D 73 00 FF FF FF FF FF FF FF FF FF FF FF FF FF
0390  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
03A0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
03B0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
03C0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
03D0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
03E0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
03F0  FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
0400  B8 22 A0 53 F0 47 B8 25 A0 03 F6 F6 17 B8 25 F0
0410  03 30 B8 24 A0 84 1C 03 41 B8 24 A0 B8 22 F0 53
0420  0F B8 25 A0 03 F6 F6 32 B8 25 F0 03 30 B8 23 A0
0430  84 37 03 41 B8 23 A0 83 D5 AE C5 23 F8 62 FF C6
0440  42 CF 54 24 D5 FE C5 93 93 FF FF FF FF FF FF FF


tasm: Number of errors = 0
