0001   0000             
0002   0000             ;************************************************
0003   0000             ; 8039 Quarz = 3,6864 Mhz                       *
0004   0000             ; f = 3,6864 Mhz / 3 = 1,2288 Mhz               *
0005   0000             ; ALE = CLK / 5 = 245,76 kHz = 4,069 us         *
0006   0000             ; TCLK int = ALE / 32 = 7,68 kHz = 130,2083 us  *
0007   0000             ; 1 cyc = 4,069 us                              *
0008   0000             ; 1 timer tick = 130 us                         *
0009   0000             ; Syntax: Telemark TASM Version 3.2             *
0010   0000             ;************************************************
0011   0000             
0012   0000             #include "mc1000.inc";
0001+  0000             
0002+  0000             NUL	= $00	; null value
0003+  0000             CR	= $0d	; Carrage return
0004+  0000             LF	= $0A	; Line feed
0005+  0000             
0006+  0000             b_WD	= $80	; watchdog bit
0007+  0000             
0008+  0000             ZP_SW1	= $20	; result of switch #1 (call rdSW12)
0009+  0000             ZP_SW2	= $21	; result of switch #2 (call rdSW12)
0010+  0000             ZP_22	= $22	; rescue 8b (b82HEX))
0011+  0000             ZP_LNIB	= $23	; low nibble result of 8b
0012+  0000             ZP_HNIB	= $24	; high nibble result of 8b
0013+  0000             ZP_25	= $25	; working nibble result
0014+  0000             ZP_26	= $26	; last pressed raw key 7279
0015+  0000             
0016+  0000             
0017+  0000             
0013   0000             #include "io.inc";
0001+  0000             
0002+  0000             
0003+  0000             IO_CD		= $03 ; P13
0004+  0000             IO_RESET	= $04 ; P14, active high
0005+  0000             
0014   0000             #include "i2c.inc";
0001+  0000             
0002+  0000             SCL = 0	; P10
0003+  0000             SDA = 1	; P11
0004+  0000             
0005+  0000             
0015   0000             #include "lcd_i2c.inc";
0001+  0000             
0002+  0000             I2CLCDWR = %01001110
0003+  0000             I2CLCDRD = %01001111
0004+  0000             
0005+  0000             
0016   0000             
0017   0000             
0018   0000             
0019   0000             .org 0000h
0020   0000             
0021   0000 04 20       _RESET		jmp INIT	; reset sprungadresse
0022   0002 00          		nop
0023   0003 24 1A       _INT		jmp INTERRUPT	; interrupt sprungadresse
0024   0005 00          		nop
0025   0006 00          		nop
0026   0007 24 11       _TINT		jmp TIMERINT	; timer interrupt sprungadresse
0027   0009 00          		nop
0028   000A             
0029   0010             .org 0010h
0030   0010             	; Platz fuer 16 Byte EPROM ID
0031   0010 30 31 32 33 	.byte	"0123456789abcdef"
0031   0014 34 35 36 37 
0031   0018 38 39 61 62 
0031   001C 63 64 65 66 
0032   0020             	
0033   0020             	; ---------------- init --------------------
0034   0020 15          INIT	dis i		; (1 cyc) interrupt verhindern
0035   0021 35          	dis tcnti	; (1 cyc) timer interrupt verhindern
0036   0022 75          	ent0 clk	; (1 cyc) T0 prozessortakt ausgeben
0037   0023             	
0038   0023 14 CD       	call I2CINIT	; init i2c - SDA and SCL high
0039   0025             	
0040   0025 34 0C       	call WATCHDOG
0041   0027 34 0C       	call WATCHDOG
0042   0029             	
0043   0029 14 D0       x0	call I2CSTART	;
0044   002B 34 0C       	call WATCHDOG
0045   002D             	
0046   002D BC 0A       	mov r4,#$0a	; 10*10ms
0047   002F 14 8B       	call wait	
0048   0031 34 0C       	call WATCHDOG
0049   0033             	
0050   0033             	; Try 1
0051   0033 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0052   0035 14 B2       	call I2COUT	;
0053   0037 23 35       	mov a,#$(%00110101) ;
0054   0039 14 B2       	call I2COUT	;
0055   003B 23 31       	mov a,#$(%00110001) ;
0056   003D 14 B2       	call I2COUT	;
0057   003F             	
0058   003F BC 01       	mov r4,#$01	; 1*10ms
0059   0041 14 8B       	call wait	
0060   0043 34 0C       	call WATCHDOG
0061   0045             	
0062   0045             	; Try 2
0063   0045 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0064   0047 14 B2       	call I2COUT	;
0065   0049 23 35       	mov a,#$(%00110101) ;
0066   004B 14 B2       	call I2COUT	;
0067   004D 23 31       	mov a,#$(%00110001) ;
0068   004F 14 B2       	call I2COUT	;
0069   0051             	
0070   0051 BC 01       	mov r4,#$01	; 1*10ms
0071   0053 14 8B       	call wait	
0072   0055 34 0C       	call WATCHDOG
0073   0057             	
0074   0057             	; Try 3
0075   0057 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0076   0059 14 B2       	call I2COUT	;
0077   005B 23 35       	mov a,#$(%00110101) ;
0078   005D 14 B2       	call I2COUT	;
0079   005F 23 31       	mov a,#$(%00110001) ;
0080   0061 14 B2       	call I2COUT	;
0081   0063             	
0082   0063 BC 01       	mov r4,#$01	; 1*10ms
0083   0065 14 8B       	call wait	
0084   0067 34 0C       	call WATCHDOG
0085   0069             	
0086   0069             	; set 4bit mode
0087   0069 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD write address
0088   006B 14 B2       	call I2COUT	;
0089   006D 23 25       	mov a,#$(%00100101) ;
0090   006F 14 B2       	call I2COUT	;
0091   0071 23 21       	mov a,#$(%00100001) ;
0092   0073 14 B2       	call I2COUT	;
0093   0075             	
0094   0075 BC 01       	mov r4,#$01	; 1*10ms
0095   0077 14 8B       	call wait	
0096   0079 34 0C       	call WATCHDOG
0097   007B             	
0098   007B 14 D7       	call I2CSTOP	;
0099   007D             	
0100   007D 34 0C       	call WATCHDOG
0101   007F 34 0C       	call WATCHDOG
0102   0081             	
0103   0081 04 81       	jmp $
0104   0083             	
0105   0083             	;call I2CSTOP
0106   0083 14 99       	call I2CIN
0107   0085 34 0C       	call WATCHDOG
0108   0087 34 0C       	call WATCHDOG
0109   0089 04 29       	jmp x0
0110   008B             	
0111   008B             	
0112   008B             	; i2c data byte
0113   008B             	;mov r0,#$ZP_SW1	; SW1 i2c address
0114   008B             	;mov a,@r0	; i2c data
0115   008B             	;clr F1		; set data  mode
0116   008B             	;call IC2OUT	;
0117   008B             	
0118   008B             	;call I2CSTOP
0119   008B             	
0120   008B             	;call WATCHDOG
0121   008B             	
0122   008B             	;jmp x0
0123   008B             
0124   008B             
0125   008B             ;*****************************************
0126   008B             ; sekunde                                *
0127   008B             ; Da aufwaertszahler, muss die diff zum  *
0128   008B             ; ueberlauf als Wert gtenommen werden    *
0129   008B             ; r4= n * 10ms
0130   008B             ;*****************************************
0131   008B 23 B3       wait		mov a,#0b3h	; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0132   008D 62          		mov t,a		; (1 cyc) timer mit akkuwert laden
0133   008E 34 0C       		call WATCHDOG	;
0134   0090 55          		strt t		; (1 cyc) timer starten
0135   0091 16 95       sek_2		jtf sek_3	; (2 cyc) timer abgelaufen
0136   0093 04 91       		jmp sek_2	; (2 cyc) warten bis timer abgelaufen
0137   0095 65          sek_3		stop tcnt	; (1 cyc) timer anhalten
0138   0096 EC 8B       		djnz r4,wait	; (2 cyc) repeat zaehler decrementieren
0139   0098 83          		ret		; (2 cyc) bye
0140   0099             
0141   0099             
0142   0099             ;*****************************************
0143   0099             ; I2C read data
0144   0099             ; SDA & SCL should be low before
0145   0099             ; r0= temp bitcounter
0146   0099             ; r3= temp data
0147   0099             ; A=  data
0148   0099             ;*****************************************
0149   0099             I2CIN
0150   0099             	; SDA & SCL should here be low
0151   0099 B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0152   009B             	
0153   009B             	; loop over 8-bit data
0154   009B             I2CO01	
0155   009B 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0156   009D 09          	in a,p1		; read P1x (SDA)
0157   009E 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0158   00A0             	
0159   00A0 97          	clr c		; C=0
0160   00A1 32 A5       	jb1 I2CO02	; SDA=1 (P1x)
0161   00A3 04 A6       	jmp I2CO03	; SDA=0 (P1x)
0162   00A5 A7          I2CO02	cpl c		; C=1
0163   00A6             	
0164   00A6 FB          I2CO03	mov a,r3	; lopad temp data
0165   00A7 F7          	rlc a		; shift carry into A
0166   00A8 AB          	mov r3,a	; save temp data
0167   00A9             	
0168   00A9 E8 9B       	djnz r0,I2CO01	; decrement bitcounter,next loop r0>0
0169   00AB             	
0170   00AB             	; check bit-9 AKN/NAKN
0171   00AB 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0172   00AD 09          	in a,p1		; read P1x
0173   00AE 00          	nop		; carry to be define
0174   00AF 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0175   00B1             	
0176   00B1 83          	ret
0177   00B2             
0178   00B2             
0179   00B2             ;*****************************************
0180   00B2             ; I2C write out address/date
0181   00B2             ; SDA & SCL should be low before
0182   00B2             ; data must be stable before and after clock
0183   00B2             ; A= address/data -> R3
0184   00B2             ; r0= temp bitcounter
0185   00B2             ; r3= temp address/data
0186   00B2             ;*****************************************
0187   00B2             I2COUT	; SDA & SCL should here be low
0188   00B2             	
0189   00B2 B8 08       	mov r0,#$08	; set bitcounter to 8-bit
0190   00B4             	
0191   00B4             	; loop over 8-bit adress+RW/data
0192   00B4 AB          I2CB01	mov r3,a	; set A to temp adress/data
0193   00B5 97          	clr c		; prerpare carry
0194   00B6 FB          	mov a,r3	; load temp adress/data
0195   00B7 F7          	rlc a		; shift bit out into carry
0196   00B8 F6 BC       	jc I2CB1	; bit set
0197   00BA 04 BE       	jmp I2CB2	; bit clear
0198   00BC 89 02       I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0199   00BE 89 01       I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0200   00C0 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0201   00C2 99 FD       	anl p1,#~(1 << SDA) ; SDA low, bit falling
0202   00C4 E8 B4       	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0203   00C6             	
0204   00C6             	; check bit-9 AKN/NAKN
0205   00C6 89 01       	orl p1,#$(1 << SCL) ; SCL high, clock rising
0206   00C8 09          	in a,p1		; read P1x
0207   00C9 00          	nop		; carry to be define
0208   00CA 99 FE       	anl p1,#~(1 << SCL) ; SCL low, clock falling
0209   00CC             	
0210   00CC 83          	ret
0211   00CD             
0212   00CD             
0213   00CD             ;;*****************************************
0214   00CD             ;; I2C write out address/date
0215   00CD             ;; SDA & SCL should be low before
0216   00CD             ;; data must be stable before and after clock
0217   00CD             ;; A= address/data -> R3
0218   00CD             ;; r0= temp bitcounter
0219   00CD             ;; r3= temp address/data
0220   00CD             ;; F0= R/W 1/0
0221   00CD             ;; F1= address/data 1/0
0222   00CD             ;;*****************************************
0223   00CD             ;I2COUT
0224   00CD             ;	mov r0,#$08	; set bitcounter to 8-bit
0225   00CD             ;	jf1 I2CB00	; F1=1 7-bit address mode + 1-bit RW
0226   00CD             ;	jmp I2CB01	; F1=0 8-bit data mode
0227   00CD             ;	
0228   00CD             ;	; adapt to address + R/W
0229   00CD             ;I2CB00	rl a		; convert A to address << 1 and b0=0 (write)
0230   00CD             ;	jf0 I2CB00A	; read mode
0231   00CD             ;	jmp I2CB01	; write mode
0232   00CD             ;I2CB00A	orl a,#$01	; b0=1 (read)
0233   00CD             ;	
0234   00CD             ;	; SDA & SCL should here be low
0235   00CD             ;	; loop over 8-bit adress+RW/data
0236   00CD             ;I2CB01	mov r3,a	; set A to temp adress/data
0237   00CD             ;	clr c		; prerpare carry
0238   00CD             ;	mov a,r3	; load temp adress/data
0239   00CD             ;	rlc a		; shift bit out into carry
0240   00CD             ;	jc I2CB1	; bit set
0241   00CD             ;	jmp I2CB2	; bit clear
0242   00CD             ;I2CB1	orl p1,#$(1 << SDA) ; SDA high, bit rising
0243   00CD             ;I2CB2	orl p1,#$(1 << SCL) ; SCL high, clock rising
0244   00CD             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0245   00CD             ;	anl p1,#~(1 << SDA) ; SDA low, bit falling
0246   00CD             ;	djnz r0,I2CB01	; decrement bitcounter,next loop r0>0
0247   00CD             ;	
0248   00CD             ;	; check bit-9 AKN/NAKN
0249   00CD             ;	orl p1,#$(1 << SCL) ; SCL high, clock rising
0250   00CD             ;	in a,p1		; read P1x
0251   00CD             ;	nop		; carry to be define
0252   00CD             ;	anl p1,#~(1 << SCL) ; SCL low, clock falling
0253   00CD             ;	
0254   00CD             ;	ret
0255   00CD             
0256   00CD             
0257   00CD             ;*****************************************
0258   00CD             ; I2C init sequence
0259   00CD             ;*****************************************
0260   00CD             I2CINIT	
0261   00CD 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0262   00CF 83          	ret
0263   00D0             
0264   00D0             
0265   00D0             ;*****************************************
0266   00D0             ; I2C start sequence
0267   00D0             ; SDA & SCL should be low before
0268   00D0             ;*****************************************
0269   00D0             I2CSTART
0270   00D0 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0271   00D2 99 FD       	anl p1,#~(1 << SDA)		; SDA low, SCL high
0272   00D4 99 FC       	anl p1,#~((1 << SDA)|(1 << SCL)) ; SDA & SCL low
0273   00D6 83          	ret				;
0274   00D7             
0275   00D7             
0276   00D7             ;*****************************************
0277   00D7             ; I2C start sequence
0278   00D7             ; SDA & SCL should be low before
0279   00D7             ;*****************************************
0280   00D7             I2CSTOP
0281   00D7             	;in a,p1
0282   00D7             	;outl p1,a
0283   00D7 89 01       	orl p1,#$(1 << SCL)		; SCL high
0284   00D9 00          	nop
0285   00DA 00          	nop
0286   00DB 89 03       	orl p1,#$((1 << SDA)|(1 << SCL)) ; SDA & SCL high
0287   00DD 00          	nop
0288   00DE 83          	ret				;
0289   00DF             
0290   00DF             
0291   00DF             ;*****************************************
0292   00DF             ;
0293   00DF             ;*****************************************
0294   00DF             BCKLGHTON
0295   00DF 14 D0       	call I2CSTART	;
0296   00E1             	; i2c address byte
0297   00E1 23 4E       	mov a,#I2CLCDWR	; i2c 7-bit LCD address
0298   00E3 85          	clr F0		; set write mode
0299   00E4 A5          	clr F1		; set data  mode
0300   00E5 B5          	cpl F1		; set address mode
0301   00E6 14 B2       	call I2COUT
0302   00E8             	
0303   00E8             	
0304   00E8             
0305   00E8             
0306   00E8              ;************************************************
0307   00E8             ; Load SW1/SW2
0308   00E8             ; R3/R4= temporary result of SW1/SW2
0309   00E8             ; $20= result of SW1
0310   00E8             ; $21= result of SW2
0311   00E8             ;************************************************
0312   00E8             rdSW12:
0313   00E8 23 10       	mov	a,#$10		; init value-corunter
0314   00EA AA          	mov	r2,a		; with %00010000
0315   00EB             L0332:
0316   00EB FB          	mov	a,r3		; move SW counter from r3
0317   00EC AC          	mov	r4,a		; to SW counter r4
0318   00ED             L0334:
0319   00ED CA          	dec	r2		; value-counter r2--
0320   00EE 09          	in	a,p1		; load current value of port1
0321   00EF 53 F0       	anl	a,#$F0		; cut low nibble
0322   00F1 4A          	orl	a,r2		; "add" value-counter r2 into
0323   00F2 39          	outl	p1,a		; write back to port1
0324   00F3 FB          	mov	a,r3		; load A with r3
0325   00F4 97          	clr	c		; clear carry
0326   00F5 56 F8       	jt1	L033F		; SW is "On"?
0327   00F7 A7          	cpl	c		; set carry (inverted val)
0328   00F8             L033F:
0329   00F8 F7          	rlc	a		; fill value with carry from right
0330   00F9 AB          	mov	r3,a		; store result to counter r3
0331   00FA FA          	mov	a,r2		; load counter r2
0332   00FB 72 EB       	jb3	L0332		; bit 3 set (SW2 active)?
0333   00FD 53 0F       	anl	a,#$0F		; cut high nibble
0334   00FF C6 03       	jz	L034A		; value-counter clear
0335   0101 04 ED       	jmp	L0334		; next loop, SW counter -> r4
0336   0103             L034A:
0337   0103 B8 20       	mov	r0,#ZP_SW1	; set index ZP $20
0338   0105 FB          	mov	a,r3		; store result from r3
0339   0106 A0          	mov	@r0,a		; to RAM $20
0340   0107 B8 21       	mov	r0,#ZP_SW2	; set index ZP $21
0341   0109 FC          	mov	a,r4		; store result from r4
0342   010A A0          	mov	@r0,a		; to RAM $21
0343   010B 83          	ret			; bye
0344   010C             
0345   010C             
0346   010C             ;*****************************************
0347   010C             ; watchdog impuls |_|- high->low -> high *
0348   010C             ; must be execute at least each ~630ms   *
0349   010C             ;*****************************************
0350   010C             WATCHDOG:
0351   010C 9A 7F       	anl p2,#$(~b_WD)	; (2 cyc) P27 Watchdog low
0352   010E 8A 80       	orl p2,#b_WD		; (2 cyc) P27 Watchdog high
0353   0110 83          	ret			; (2 cyc)
0354   0111             
0355   0111             
0356   0111             
0357   0111             ;***********************************************
0358   0111             ; Timer interrupt routine alle 10,02 ms        *
0359   0111             ;***********************************************
0360   0111             TIMERINT:
0361   0111 93          	retr
0362   0112             	
0363   0112             	
0364   0112 23 B3       	mov a,#0b3h		; (1 cyc) 9,8 ms. Da aufwaertszaehler, muss #76 ((255-179) x 130,2 us)
0365   0114 62          	mov t,a			; (1 cyc) timer mit akkuwert laden
0366   0115 09          	in a,p1			; (2 cyc) lese port #1 in kku
0367   0116 D3 80       	xrl a,#b_WD		; (2 cyc) XOR akku mit bit 7
0368   0118 39          	outl p1,a		; (2 cyc) schreibe akku nach port #1
0369   0119 93          	retr			; (2 cyc) return mit PSW restore
0370   011A             
0371   011A             ;***********************************************
0372   011A             ; interrupt routine                            *
0373   011A             ;***********************************************
0374   011A             INTERRUPT:
0375   011A 93          	retr			;
0376   011B             
0377   011B             
0378   011B             
0379   011B             .end
0380   011B             



Type Key: N=NULL_SEG C=CODE_SEG B=BIT_SEG X=EXTD_SEG D=DATA_SEG
          L=Local
          E=Export

Value    Type   Label
-----    ----   ------------------------------
00DF     N      BCKLGHTON                       
000D     N      CR                              
0003     N      IO_CD                           
0004     N      IO_RESET                        
004E     N      I2CLCDWR                        
004F     N      I2CLCDRD                        
0020     N      INIT                            
0099     N      I2CIN                           
009B     N      I2CO01                          
00A5     N      I2CO02                          
00A6     N      I2CO03                          
00B2     N      I2COUT                          
00B4     N      I2CB01                          
00BC     N      I2CB1                           
00BE     N      I2CB2                           
00CD     N      I2CINIT                         
00D0     N      I2CSTART                        
00D7     N      I2CSTOP                         
011A     N      INTERRUPT                       
000A     N      LF                              
00EB     N      L0332                           
00ED     N      L0334                           
00F8     N      L033F                           
0103     N      L034A                           
0000     N      NUL                             
0000     N      SCL                             
0001     N      SDA                             
0111     N      TIMERINT                        
010C     N      WATCHDOG                        
0020     N      ZP_SW1                          
0021     N      ZP_SW2                          
0022     N      ZP_22                           
0023     N      ZP_LNIB                         
0024     N      ZP_HNIB                         
0025     N      ZP_25                           
0026     N      ZP_26                           
0080     N      b_WD                            
0000     NL     noname._RESET                   
0003     NL     noname._INT                     
0007     NL     noname._TINT                    
00E8     N      rdSW12                          
0091     N      sek_2                           
0095     N      sek_3                           
008B     N      wait                            
0029     N      x0                              


ADDR  00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
-----------------------------------------------------
0000  04 20 00 24 1A 00 00 24 11 00 FF FF FF FF FF FF
0010  30 31 32 33 34 35 36 37 38 39 61 62 63 64 65 66
0020  15 35 75 14 CD 34 0C 34 0C 14 D0 34 0C BC 0A 14
0030  8B 34 0C 23 4E 14 B2 23 35 14 B2 23 31 14 B2 BC
0040  01 14 8B 34 0C 23 4E 14 B2 23 35 14 B2 23 31 14
0050  B2 BC 01 14 8B 34 0C 23 4E 14 B2 23 35 14 B2 23
0060  31 14 B2 BC 01 14 8B 34 0C 23 4E 14 B2 23 25 14
0070  B2 23 21 14 B2 BC 01 14 8B 34 0C 14 D7 34 0C 34
0080  0C 04 81 14 99 34 0C 34 0C 04 29 23 B3 62 34 0C
0090  55 16 95 04 91 65 EC 8B 83 B8 08 89 01 09 99 FE
00A0  97 32 A5 04 A6 A7 FB F7 AB E8 9B 89 01 09 00 99
00B0  FE 83 B8 08 AB 97 FB F7 F6 BC 04 BE 89 02 89 01
00C0  99 FE 99 FD E8 B4 89 01 09 00 99 FE 83 89 03 83
00D0  89 03 99 FD 99 FC 83 89 01 00 00 89 03 00 83 14
00E0  D0 23 4E 85 A5 B5 14 B2 23 10 AA FB AC CA 09 53
00F0  F0 4A 39 FB 97 56 F8 A7 F7 AB FA 72 EB 53 0F C6
0100  03 04 ED B8 20 FB A0 B8 21 FC A0 83 9A 7F 8A 80
0110  83 93 23 B3 62 09 D3 80 39 93 93 FF FF FF FF FF


tasm: Number of errors = 0
